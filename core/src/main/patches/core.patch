Index: org/apache/solr/search/SolrIndexSearcher.java
===================================================================
--- org/apache/solr/search/SolrIndexSearcher.java	(revision 885060)
+++ org/apache/solr/search/SolrIndexSearcher.java	(working copy)
@@ -17,28 +17,31 @@
 
 package org.apache.solr.search;
 
-import org.apache.lucene.document.*;
+import org.apache.lucene.document.Document;
+import org.apache.lucene.document.FieldSelector;
+import org.apache.lucene.document.FieldSelectorResult;
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.index.TermDocs;
 import org.apache.lucene.search.*;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.store.FSDirectory;
+import org.apache.lucene.util.OpenBitSet;
 import org.apache.solr.common.util.NamedList;
 import org.apache.solr.common.util.SimpleOrderedMap;
 import org.apache.solr.core.SolrConfig;
 import org.apache.solr.core.SolrCore;
 import org.apache.solr.core.SolrInfoMBean;
+import org.apache.solr.request.UnInvertedField;
 import org.apache.solr.schema.IndexSchema;
 import org.apache.solr.schema.SchemaField;
-import org.apache.solr.request.UnInvertedField;
-import org.apache.lucene.util.OpenBitSet;
+import org.apache.solr.util.DocSetScoreCollector;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 import java.io.IOException;
 import java.net.URL;
 import java.util.*;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
 
 
 /**
@@ -527,23 +530,51 @@
    * This method can handle negative queries.
    * <p>
    * The DocSet returned should <b>not</b> be modified.
+   *
+   * @param query The specified query that must match with the document ids
+   * @return the set of document ids matching all queries. Set may not be modified
+   * @throws IOException If an IO related exception occurs
    */
   public DocSet getDocSet(Query query) throws IOException {
+    return getDocSet(query, (DocSetAwareCollector) null);
+  }
+
+  /**
+   * Returns the set of document ids matching a query.
+   * This method is cache-aware and attempts to retrieve the answer from the cache if possible.
+   * If the answer was not cached, it may have been inserted into the cache as a result of this call.
+   * This method can handle negative queries.
+   * <p>
+   * The DocSet returned should <b>not</b> be modified.
+   *
+   * <p>
+   * This method allows a custom collector the be specified to collect results in a custum way. For example to also
+   * collect the score of a collected document
+   *
+   * @param query The specified query that must match with the document ids
+   * @param collector A docset aware collector that collects the result
+   * @return the set of document ids matching all queries. Set may not be modified
+   * @throws IOException If an IO related exception occurs
+   */
+  public DocSet getDocSet(Query query, DocSetAwareCollector collector) throws IOException {
     // Get the absolute value (positive version) of this query.  If we
     // get back the same reference, we know it's positive.
     Query absQ = QueryUtils.getAbs(query);
-    boolean positive = query==absQ;
+    boolean positive = query == absQ;
 
     if (filterCache != null) {
-      DocSet absAnswer = (DocSet)filterCache.get(absQ);
+      DocSet absAnswer = (DocSet) filterCache.get(absQ);
       if (absAnswer!=null) {
-        if (positive) return absAnswer;
-        else return getPositiveDocSet(matchAllDocsQuery).andNot(absAnswer);
+        if (positive) {
+          return absAnswer;
+        } else {
+          return getPositiveDocSet(matchAllDocsQuery, collector).andNot(absAnswer);
+        }
       }
     }
 
-    DocSet absAnswer = getDocSetNC(absQ, null);
-    DocSet answer = positive ? absAnswer : getPositiveDocSet(matchAllDocsQuery).andNot(absAnswer);
+    DocSet absAnswer = getDocSetNC(absQ, null, collector);
+    DocSet answer = positive ? absAnswer : getPositiveDocSet(matchAllDocsQuery, collector).andNot(absAnswer);
 
     if (filterCache != null) {
       // cache negative queries as positive
@@ -555,17 +586,21 @@
 
   // only handle positive (non negative) queries
   DocSet getPositiveDocSet(Query q) throws IOException {
+    return getPositiveDocSet(q, null);
+  }
+
+  // only handle positive (non negative) queries
+  DocSet getPositiveDocSet(Query q, DocSetAwareCollector collector) throws IOException {
     DocSet answer;
     if (filterCache != null) {
       answer = (DocSet)filterCache.get(q);
       if (answer!=null) return answer;
     }
-    answer = getDocSetNC(q,null);
+    answer = getDocSetNC(q, null, collector);
     if (filterCache != null) filterCache.put(q,answer);
     return answer;
   }
 
-
   private static Query matchAllDocsQuery = new MatchAllDocsQuery();
 
   /**
@@ -575,6 +610,10 @@
    * This method can handle negative queries.
    * <p>
    * The DocSet returned should <b>not</b> be modified.
+   *
+   * @param queries The specified list of queries that must match with the document ids
+   * @return the set of document ids matching all queries. Set may not be modified
+   * @throws IOException If an IO related exception occurs
    */
   public DocSet getDocSet(List<Query> queries) throws IOException {
     if (queries==null) return null;
@@ -624,10 +663,17 @@
 
   // query must be positive
   protected DocSet getDocSetNC(Query query, DocSet filter) throws IOException {
-    DocSetCollector collector = new DocSetCollector(maxDoc()>>6, maxDoc());
+    return getDocSetNC(query,  filter, null);
+  }
 
+  // query must be positive
+  protected DocSet getDocSetNC(Query query, DocSet filter, DocSetAwareCollector collector) throws IOException {
+    if (collector == null) {
+      collector = new DocSetCollector(maxDoc()>>6, maxDoc());
+    }
+
     if (filter==null) {
-      if (query instanceof TermQuery) {
+        if (query instanceof TermQuery && !(collector instanceof DocSetScoreCollector)) {
         Term t = ((TermQuery)query).getTerm();
         SolrIndexReader[] readers = reader.getLeafReaders();
         int[] offsets = reader.getLeafOffsets();
@@ -659,7 +705,6 @@
     }
   }
 
-
   /**
    * Returns the set of document ids matching both the query and the filter.
    * This method is cache-aware and attempts to retrieve the answer from the cache if possible.
@@ -671,8 +716,22 @@
    * @return DocSet meeting the specified criteria, should <b>not</b> be modified by the caller.
    */
   public DocSet getDocSet(Query query, DocSet filter) throws IOException {
-    if (filter==null) return getDocSet(query);
+    return getDocSet(query, filter, null);
+  }
 
+  /**
+   * Returns the set of document ids matching both the query and the filter.
+   * This method is cache-aware and attempts to retrieve the answer from the cache if possible.
+   * If the answer was not cached, it may have been inserted into the cache as a result of this call.
+   * <p>
+   *
+   * @param query
+   * @param filter may be null
+   * @return DocSet meeting the specified criteria, should <b>not</b> be modified by the caller.
+   */
+  public DocSet getDocSet(Query query, DocSet filter, DocSetAwareCollector collector) throws IOException {
+    if (filter==null) return getDocSet(query, collector);
+
     // Negative query if absolute value different from original
     Query absQ = QueryUtils.getAbs(query);
     boolean positive = absQ==query;
@@ -688,7 +747,7 @@
     }
 
     // If there isn't a cache, then do a single filtered query if positive.
-    return positive ? getDocSetNC(absQ,filter) : filter.andNot(getPositiveDocSet(absQ));
+    return positive ? getDocSetNC(absQ,filter,collector) : filter.andNot(getPositiveDocSet(absQ, collector));
   }
 
 
@@ -1196,6 +1255,43 @@
   }
 
   /**
+   * Returns documents matching both <code>query</code> and the intersection
+   * of <code>filterList</code>, sorted by <code>sort</code>.
+   * Also returns the compete set of documents
+   * matching <code>query</code> and <code>filter</code>
+   * (regardless of <code>offset</code> and <code>len</code>).
+   * <p>
+   * This method is cache aware and may retrieve <code>filter</code> from
+   * the cache or make an insertion into the cache as a result of this call.
+   * <p>
+   * FUTURE: The returned DocList may be retrieved from a cache.
+   * <p>
+   * The DocList and DocSet returned should <b>not</b> be modified.
+   *
+   * @param query       The main query
+   * @param filterList   may be null
+   * @param docSet      filter docSet
+   * @param lsort    criteria by which to sort (if null, query relevance is used)
+   * @param offset   offset into the list of documents to return
+   * @param len      maximum number of documents to return
+   * @param flags    user supplied flags for the result set
+   * @return DocListAndSet meeting the specified criteria, should <b>not</b> be modified by the caller.
+   * @throws IOException If an IO related exception occurs
+   */
+  public DocListAndSet getDocListAndSet(Query query, List<Query> filterList, DocSet docSet, Sort lsort, int offset, int len, int flags) throws IOException {
+    //DocListAndSet ret = new DocListAndSet();
+    //getDocListC(ret,query,filterList,docSet,lsort,offset,len, flags |= GET_DOCSET);
+
+    QueryCommand qc = new QueryCommand();
+    qc.setQuery(query).setFilterList(filterList).setFilter(docSet);
+    qc.setSort(lsort).setOffset(offset).setLen(len).setFlags(flags |= GET_DOCSET);
+    QueryResult result = new QueryResult();
+    getDocListC(result,qc);
+
+    return result.getDocListAndSet();
+  }
+
+  /**
    * Returns documents matching both <code>query</code> and <code>filter</code>
    * and sorted by <code>sort</code>.  Also returns the compete set of documents
    * matching <code>query</code> and <code>filter</code> (regardless of <code>offset</code> and <code>len</code>).
Index: org/apache/solr/search/DocSetHitCollector.java
===================================================================
--- org/apache/solr/search/DocSetHitCollector.java	(revision 885060)
+++ org/apache/solr/search/DocSetHitCollector.java	(working copy)
@@ -17,11 +17,10 @@
 
 package org.apache.solr.search;
 
-import org.apache.lucene.search.HitCollector;
+import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.search.Collector;
 import org.apache.lucene.search.Scorer;
 import org.apache.lucene.util.OpenBitSet;
-import org.apache.lucene.index.IndexReader;
 
 import java.io.IOException;
 
@@ -29,7 +28,7 @@
  * @version $Id$
  */
 
-class DocSetCollector extends Collector {
+class DocSetCollector extends DocSetAwareCollector {
   int pos=0;
   OpenBitSet bits;
   final int maxDoc;
Index: org/apache/solr/search/fieldcollapse/AbstractDocumentCollapser.java
===================================================================
--- org/apache/solr/search/fieldcollapse/AbstractDocumentCollapser.java	(revision 0)
+++ org/apache/solr/search/fieldcollapse/AbstractDocumentCollapser.java	(revision 0)
@@ -0,0 +1,365 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.search.fieldcollapse;
+
+import org.apache.lucene.search.FieldCache;
+import org.apache.lucene.search.Query;
+import org.apache.lucene.search.Sort;
+import org.apache.lucene.util.OpenBitSet;
+import org.apache.solr.common.params.CollapseParams;
+import org.apache.solr.common.params.SolrParams;
+import org.apache.solr.common.util.NamedList;
+import org.apache.solr.handler.component.ResponseBuilder;
+import org.apache.solr.request.SolrQueryRequest;
+import org.apache.solr.schema.IndexSchema;
+import org.apache.solr.schema.SchemaField;
+import org.apache.solr.search.*;
+import org.apache.solr.search.fieldcollapse.collector.CollapseCollector;
+import org.apache.solr.search.fieldcollapse.collector.CollapseCollectorFactory;
+import org.apache.solr.search.fieldcollapse.collector.CollapseContext;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Base <code>Collapser</code> implementation
+ */
+public abstract class AbstractDocumentCollapser implements DocumentCollapser {
+
+  /**
+   * Field to use to collapse results. Parameter.
+   */
+  protected final String collapseField;
+
+  /**
+   * Number of documents with the same value for collapseField after which
+   * collapsing kicks in. Parameter.
+   */
+  protected final int collapseThreshold;
+
+  /** Collapse State *********************************************** */
+
+  /**
+   * Maximum number of documents to process during field collapsing.
+   * Parameter.
+   */
+  protected final int collapseMaxDocs;
+
+  /**
+   * Whether to include debug information in the request
+   */
+  protected boolean includeDebugInformation;
+
+  /**
+   * Maxmimum size for a HashDocSet.
+   */
+  protected final int hashMaxSize;
+
+  /**
+   * Buffer for collecting documents. Gets turned into different types of
+   * DocSet depending on the number of documents we end up with.
+   */
+  protected int[] docbuf;
+
+  /**
+   * Number of documents in docbuf.
+   */
+  protected int docbufSize = 0;
+
+  /**
+   * Maximum document id currently in docbuf. Only valid while docbufSize <
+   * hashMaxSize.
+   */
+  protected int docbufMaxDoc = 0;
+
+  /**
+   * Bitset representation of docbuf. Gets created when docbufSize >=
+   * hashMaxSize.
+   */
+  protected OpenBitSet docbufBitSet;
+
+  /**
+   * The result of executing the query and filter queries, without collapsing.
+   */
+  protected DocSet uncollapsedDocSet;
+
+  protected FieldCache.StringIndex fieldValues;
+  protected final SolrIndexSearcher searcher;
+  protected final List<CollapseCollector> collectors;
+
+
+  protected final int flags;
+
+  protected final CollapseContext collapseContext;
+
+  private final List<CollapseCollectorFactory> collapseCollectorFactories;
+
+  /**
+   * Debug Information ********************************************
+   */
+  protected long timeCollapsing = 0;
+  protected long timeConvertToBitSet = 0;
+  protected long timeCreateDocSet = 0;
+  protected long timeCreateCollapseInfo = 0;
+  protected long timeCreateUncollapedDocset = 0;
+  protected String debugDocSetInfo = "unknown";
+
+
+  // ============================================ Constructors =======================================================
+
+  /**
+   * Constructs a base collapser.
+   *
+   * @param rb The response builder
+   * @param collapseCollectorFactories A list of collapse collector factories configured for the document collapser
+   * @throws IOException if index searcher related problems occur
+   */
+  protected AbstractDocumentCollapser(ResponseBuilder rb, List<CollapseCollectorFactory> collapseCollectorFactories) throws IOException {
+    this.collapseCollectorFactories = collapseCollectorFactories;
+
+    // Allocate data structures
+    hashMaxSize = rb.req.getCore().getSolrConfig().hashDocSetMaxSize;
+    docbuf = new int[hashMaxSize];
+    this.searcher = rb.req.getSearcher();
+    this.flags = rb.getFieldFlags();
+
+    // parsing Solr parameters
+    SolrParams params = rb.req.getParams();
+    collapseField = params.required().get(CollapseParams.COLLAPSE_FIELD);
+    Integer ct = params.getInt(CollapseParams.COLLAPSE_THRESHOLD);
+    if (ct == null) {
+      ct = params.getInt(CollapseParams.COLLAPSE_MAX);
+    }
+    collapseThreshold = ct != null ? ct : 1;
+    checkCollapseField(rb.req.getSchema());
+
+    int collapseMaxDocs = params.getInt(CollapseParams.COLLAPSE_MAXDOCS, 0);
+    this.collapseMaxDocs = collapseMaxDocs <= 0 ? searcher.maxDoc() : collapseMaxDocs;
+    includeDebugInformation = params.getBool(CollapseParams.COLLAPSE_DEBUG ,false);
+
+    collapseContext = new CollapseContext();
+    collectors = initializeCollapseCollectors(rb.req);
+  }
+
+
+  // ======================================= Public API methods ========================================================
+
+  /**
+   * {@inheritDoc}
+   */
+  public DocumentCollapseResult collapse(Query mainQuery, List<Query> filterQueries, Sort sort) throws IOException {
+    long startTime = System.currentTimeMillis();
+    doQuery(mainQuery, filterQueries, sort);
+    timeCreateUncollapedDocset = System.currentTimeMillis() - startTime;
+    fieldValues = FieldCache.DEFAULT.getStringIndex(searcher.getReader(), collapseField);
+    doCollapsing(uncollapsedDocSet, fieldValues);
+    return createDocumentCollapseResult();
+  }
+
+  /**
+   * {@inheritDoc}
+   */
+  public NamedList<Object> getCollapseInfo(SolrIndexSearcher searcher, DocList docs) throws IOException {
+    if (uncollapsedDocSet == null) {
+      throw new IllegalStateException("Invoke the collapse method before invoking getCollapseInfo method");
+    }
+
+    long startTime = System.currentTimeMillis();
+
+    NamedList<Object> collapseResponse = new NamedList<Object>();
+    collapseResponse.add("field", collapseField);
+
+    NamedList<Object> collapseResult = new NamedList<Object>();
+    for (CollapseCollector collapseCollector : collectors) {
+      collapseCollector.getResult(collapseResult, docs, collapseContext);
+    }
+    collapseResponse.add("results", collapseResult);
+
+    if (includeDebugInformation) {
+      collapseResponse.add("debug", getDebugInfo());
+    }
+
+    timeCreateCollapseInfo = System.currentTimeMillis() - startTime;
+    return collapseResponse;
+  }
+
+
+  // ================================================= Helpers =======================================================
+
+  /**
+   * Executes implementation specific collapsing algorithm.
+   *
+   * @param uncollapsedDocset The uncollapsed DocSet
+   * @param values The field values
+   */
+  protected abstract void doCollapsing(DocSet uncollapsedDocset, FieldCache.StringIndex values);
+
+  /**
+   * @return timing information for field collapsing process.
+   */
+  protected NamedList getDebugInfo() {
+    long totalTime = timeCreateUncollapedDocset + timeCollapsing + timeCreateCollapseInfo + timeConvertToBitSet + timeCreateDocSet;
+    NamedList<Object> namedList = new NamedList<Object>();
+    namedList.add("Docset type", debugDocSetInfo);
+    namedList.add("Total collapsing time(ms)", totalTime);
+    namedList.add("Create uncollapsed docset(ms)", timeCreateUncollapedDocset);
+    namedList.add(String.format("%s collapsing time(ms)", getClass().getSimpleName()), timeCollapsing);
+    namedList.add("Creating collapseinfo time(ms)", timeCreateCollapseInfo);
+    namedList.add("Convert to bitset time(ms)", timeConvertToBitSet);
+    namedList.add("Create collapsed docset time(ms)", timeCreateDocSet);
+    return namedList;
+  }
+
+  /**
+   * Creates the document collapse result based on the uncollapsed docset and the collapsed docset.
+   *
+   * @return he document collapse result
+   */
+  protected DocumentCollapseResult createDocumentCollapseResult() {
+    long startTime = System.currentTimeMillis();
+    DocSet result = (docbufBitSet != null) ? new BitDocSet(docbufBitSet) : new HashDocSet(docbuf, 0, docbufSize);
+    timeCreateDocSet = System.currentTimeMillis() - startTime;
+    debugDocSetInfo = result.getClass().getSimpleName() + "(" + docbufSize + ")";
+    return new DocumentCollapseResult(result, uncollapsedDocSet);
+  }
+
+  /**
+   * Adds a document to the internal document buffer.
+   *
+   * @param doc The lucene identifier of the document to add
+   */
+  protected void addDoc(int doc) {
+    // If we have less than hashMaxSize documents, just
+    // keep adding them to docbuf. We will turn them into
+    // a HashDocSet later.
+    if (docbufSize < hashMaxSize) {
+      docbuf[docbufSize] = doc;
+      if (doc > docbufMaxDoc) {
+        docbufMaxDoc = doc;
+      }
+    } else {
+      // We have exceeded hashMaxSize. Allocate a bit set
+      // if we don't have one yet, then add to that.
+      if (docbufBitSet == null) {
+        long startTime = System.currentTimeMillis();
+        docbufBitSet = new OpenBitSet(docbufMaxDoc + 1);
+        for (int i = 0; i < docbufSize; i++) {
+          docbufBitSet.fastSet(docbuf[i]);
+        }
+        timeConvertToBitSet = System.currentTimeMillis() - startTime;
+      }
+      docbufBitSet.set(doc);
+    }
+    docbufSize++;
+  }
+
+  protected void doQuery(Query mainQuery, List<Query> filterQueries, Sort sort) throws IOException {
+    uncollapsedDocSet = searcher.getDocList(mainQuery, filterQueries, sort, 0, collapseMaxDocs, flags);
+  }
+
+  /**
+   * Method that checks if proper field collapsing is actually possible with the current collapse field.
+   * If the collapse field does not meet the proper requirements a runtime exception is thrown.
+   * A runtime exception is thrown under the following circumstances:
+   * <ul>
+   *  <li> When the collapse field does not exists in the schema
+   *  <li> When the collapse field is multivalued in the schema
+   *  <li> When the collapse field is tokenized in the schema
+   * </ul>
+   *
+   * For example when a field is tokenized, only the last token of the field can be retrieved from the fieldcache. This
+   * results in field collapsing only on the last token of a field value instead of the complete field value.
+   *
+   * When the field values from a multivalued field are returned from the <code>FieldCache</code> then an exception may
+   * be thrown. This happens when there are more terms in a field than documents.
+   *
+   * @param schema The index schema
+   */
+  protected void checkCollapseField(IndexSchema schema) {
+    SchemaField schemaField = schema.getFieldOrNull(collapseField);
+    if (schemaField == null) {
+      throw new RuntimeException("Could not collapse, because collapse field does not exist in the schema.");
+    }
+
+    if (schemaField.multiValued()) {
+      throw new RuntimeException("Could not collapse, because collapse field is multivalued");
+    }
+
+    if (schemaField.getType().isTokenized()) {
+      throw new RuntimeException("Could not collapse, because collapse field is tokenized");
+    }
+  }
+
+  protected List<CollapseCollector> initializeCollapseCollectors(SolrQueryRequest request) {
+    List<CollapseCollector> collectors = new ArrayList<CollapseCollector>();
+    for (CollapseCollectorFactory factory : collapseCollectorFactories) {
+      CollapseCollector collapseCollector = factory.createCollapseCollector(request);
+      if (collapseCollector != null) {
+        if (collectors.isEmpty()) {
+          collectors.add(new DocumentHeadCollapseGroupCollector());
+        }
+
+        collectors.add(collapseCollector);
+      }
+    }
+    return collectors;
+  }
+
+  // =========================================== Getters / Setters ===================================================
+
+ /**
+   * @return field to use to collapse results
+   */
+  public String getCollapseField() {
+    return collapseField;
+  }
+
+  /**
+   * @return maximum number of documents to process during field collapsing
+   */
+  public int getCollapseMaxDocs() {
+    return collapseMaxDocs;
+  }
+
+  /**
+   * @return number of documents with the same value for collapseField after which collapsing kicks in.
+   */
+  public int getCollapseThreshold() {
+    return collapseThreshold;
+  }
+
+
+  //============================================== Inner classes =======================================================
+
+  // Collector that associates a collapse group with the document head identifier.
+  // This is information that many collapse collectors utilize.
+  // This collector has to be the first collector. Order does matter.
+  public static class DocumentHeadCollapseGroupCollector implements CollapseCollector {
+
+    public void documentCollapsed(int docId, CollapseGroup collapseGroup, CollapseContext collapseContext) {
+    }
+
+    public void documentHead(int docHeadId, CollapseGroup collapseGroup, CollapseContext collapseContext) {
+      collapseContext.getDocumentHeadCollapseGroupAssociation().put(docHeadId, collapseGroup);
+    }
+
+    public void getResult(NamedList result, DocList docs, CollapseContext collapseContext) {
+    }
+  }
+}
Index: org/apache/solr/search/fieldcollapse/AdjacentDocumentCollapser.java
===================================================================
--- org/apache/solr/search/fieldcollapse/AdjacentDocumentCollapser.java	(revision 0)
+++ org/apache/solr/search/fieldcollapse/AdjacentDocumentCollapser.java	(revision 0)
@@ -0,0 +1,158 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.search.fieldcollapse;
+
+import org.apache.lucene.search.FieldCache;
+import org.apache.solr.handler.component.ResponseBuilder;
+import org.apache.solr.search.DocIterator;
+import org.apache.solr.search.DocSet;
+import org.apache.solr.search.fieldcollapse.collector.CollapseCollector;
+import org.apache.solr.search.fieldcollapse.collector.CollapseCollectorFactory;
+
+import java.io.IOException;
+import java.util.List;
+
+/**
+ * Adjacent collapsing behaviour. Has the same behaviour as {@link NonAdjacentDocumentCollapser} but with one extra constraint.
+ * The collapsing happens in an adjacent manner. Meaning that only documents that are next to each other in a continuous
+ * row and that have the same field value might be collapsed.
+ */
+public class AdjacentDocumentCollapser extends AbstractDocumentCollapser {
+
+  /**
+   * See {@link super#AbstractDocumentCollapser(org.apache.solr.handler.component.ResponseBuilder, List)}
+   */
+  public AdjacentDocumentCollapser(ResponseBuilder rb, List<CollapseCollectorFactory> collapseCollectorFactories) throws IOException {
+    super(rb, collapseCollectorFactories);
+  }
+
+
+  // ================================================= Helpers =========================================================
+
+  /**
+   * Applies adjacent collapsing on the specified uncollapsedDocSet.
+   *
+   * @param uncollapsedDocset The uncollapsed docset
+   * @param values            The fieldvalues the collapse on
+   */
+  protected void doCollapsing(DocSet uncollapsedDocset, FieldCache.StringIndex values) {
+    int docCount = 0; // how many documents we have processed
+    int repeatCount = 0; // how many times we have seen the same value in a
+    int collapseCount = 0; // how many documents we have collapsed in this
+    int collapseId = -1; // the document we're collapsing into
+    String collapseValue = null;
+
+
+    long startTime = System.currentTimeMillis();
+    for (DocIterator i = uncollapsedDocset.iterator(); i.hasNext();) {
+      int currentId = i.nextDoc();
+      String currentValue = values.lookup[values.order[currentId]];
+      
+      // Initializing
+      if (collapseValue == null) {
+        repeatCount = 0;
+        collapseCount = 0;
+        collapseId = currentId;
+        collapseValue = currentValue;
+
+        // Collapse the document if the field value is the same and
+        // we have a run of at least collapseThreshold uncollapsedDocset.
+      } else if (collapseValue.equals(currentValue)) {
+        if (++repeatCount >= collapseThreshold) {
+          collapseCount++;
+          for (CollapseCollector collector : collectors) {
+            CollapseGroup valueToCollapse = new AdjacentCollapseGroup(collapseId, currentValue);
+            collector.documentCollapsed(currentId, valueToCollapse, collapseContext);
+          }
+        } else {
+          addDoc(currentId);
+        }
+      } else {
+        addDoc(collapseId);
+        if (collapseCount > 0) {
+          CollapseGroup valueToCollapse = new AdjacentCollapseGroup(collapseId, collapseValue);
+          for (CollapseCollector collector : collectors) {
+            collector.documentHead(collapseId, valueToCollapse, collapseContext);
+          }
+        }
+
+        repeatCount = 0;
+        collapseCount = 0;
+        collapseId = currentId;
+        collapseValue = currentValue;
+      }
+
+      // Stop after collapseMaxDocs documents
+      if (++docCount >= collapseMaxDocs) {
+        break;
+      }
+    }
+
+    if (collapseId != -1) {
+      addDoc(collapseId);
+    }
+
+    if (collapseCount > 0) {
+      CollapseGroup valueToCollapse = new AdjacentCollapseGroup(collapseId, collapseValue);
+      for (CollapseCollector collector : collectors) {
+          collector.documentHead(collapseId, valueToCollapse, collapseContext);
+      }
+    }
+
+    timeCollapsing = System.currentTimeMillis() - startTime;
+  }
+
+
+  // ============================================ Inner Classes ========================================================
+
+  private static class AdjacentCollapseGroup implements CollapseGroup {
+
+    private final int firstDocumentId;
+    private final String fieldValue;
+
+    private AdjacentCollapseGroup(int firstDocumentId, String fieldValue) {
+      this.firstDocumentId = firstDocumentId;
+      this.fieldValue = fieldValue;
+    }
+
+    public String getKey() {
+      return fieldValue;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+      if (this == o) return true;
+      if (o == null || getClass() != o.getClass()) return false;
+
+      AdjacentCollapseGroup that = (AdjacentCollapseGroup) o;
+
+      if (firstDocumentId != that.firstDocumentId) return false;
+      if (fieldValue != null ? !fieldValue.equals(that.fieldValue) : that.fieldValue != null) return false;
+
+      return true;
+    }
+
+    @Override
+    public int hashCode() {
+      int result = firstDocumentId;
+      result = 31 * result + (fieldValue != null ? fieldValue.hashCode() : 0);
+      return result;
+    }
+  }
+
+}
Index: org/apache/solr/search/fieldcollapse/CollapseGroup.java
===================================================================
--- org/apache/solr/search/fieldcollapse/CollapseGroup.java	(revision 0)
+++ org/apache/solr/search/fieldcollapse/CollapseGroup.java	(revision 0)
@@ -0,0 +1,37 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.search.fieldcollapse;
+
+/**
+ * A <code>CollapseGroup</code> represents a logical group where documents are collaped into.
+ * Per {@link DocumentCollapser} the definition of a collapse group may differ.
+ * <p>
+ * The uniqueness of the group is specified by its hashcode and equals method. All {@link DocumentCollapser} implementations
+ * must have a proper implementation of these methods.
+ */
+public interface CollapseGroup {
+
+  /**
+   * Returns the value for presentation purposes in the response.
+   * This may not be an unique value.
+   *
+   * @return the value for presentation purposes in the response
+   */
+  String getKey();
+
+}
Index: org/apache/solr/search/fieldcollapse/DocumentCollapseResult.java
===================================================================
--- org/apache/solr/search/fieldcollapse/DocumentCollapseResult.java	(revision 0)
+++ org/apache/solr/search/fieldcollapse/DocumentCollapseResult.java	(revision 0)
@@ -0,0 +1,57 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.solr.search.fieldcollapse;
+
+import org.apache.solr.search.DocSet;
+
+/**
+ * Contains the collapsed and uncollapsed result.
+ */
+public class DocumentCollapseResult {
+
+    private final DocSet collapsedDocset;
+    private final DocSet unCollapsedDocset;
+
+    /**
+     * Constructs a <code>DocumentCollapseResult</code>.
+     *
+     * @param collapsedDocset The collapsed docset
+     * @param unCollapsedDocset The uncollapsed docset
+     */
+    public DocumentCollapseResult(DocSet collapsedDocset, DocSet unCollapsedDocset) {
+        this.collapsedDocset = collapsedDocset;
+        this.unCollapsedDocset = unCollapsedDocset;
+    }
+
+    /**
+     * Returns the collapsed docset.
+     *
+     * @return the collapsed docset
+     */
+    public DocSet getCollapsedDocset() {
+        return collapsedDocset;
+    }
+
+    /**
+     * Returns the uncollapsed docset.
+     *
+     * @return the uncollapsed docset
+     */
+    public DocSet getUnCollapsedDocset() {
+        return unCollapsedDocset;
+    }
+}
Index: org/apache/solr/search/fieldcollapse/DocumentCollapser.java
===================================================================
--- org/apache/solr/search/fieldcollapse/DocumentCollapser.java	(revision 0)
+++ org/apache/solr/search/fieldcollapse/DocumentCollapser.java	(revision 0)
@@ -0,0 +1,70 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.search.fieldcollapse;
+
+import org.apache.lucene.search.Query;
+import org.apache.lucene.search.Sort;
+import org.apache.solr.common.util.NamedList;
+import org.apache.solr.search.DocList;
+import org.apache.solr.search.SolrIndexSearcher;
+
+import java.io.IOException;
+import java.util.List;
+
+/**
+ * A document collapser is responsible for removing documents that have the same value on a predefined field,
+ * only the most relevant (based sorting and / or scoring) documents will <b>not</b> be removed.<br />
+ * <br />
+ * Besides that a document collapser also creates statistics about the collaped docset e.g. how many documents
+ * were collapsed under the most relevant document and how many documents were collaped under a certain field value.
+ */
+public interface DocumentCollapser {
+
+  /**
+   * Executes a search based on the specified parameters
+   * Returns a docset only containing the non collapsed documents also known as the document heads.
+   *
+   * @param mainQuery     The main query
+   * @param filterQueries The filter queries
+   * @param sort          The sort
+   * @return a docset only containing the non collapsed documents
+   * @throws IOException if index searcher related problems occur
+   */
+  DocumentCollapseResult collapse(Query mainQuery, List<Query> filterQueries, Sort sort) throws IOException;
+
+  /**
+   * Returns the statistics about the collapsed <code>DocSet</code>.
+   * The following information is returned:
+   * <ul>
+   *  <li> The fieldname used during collapsing
+   *  <li> A list of head document ids and how many documents were collapsed under it
+   *  <li> A list of field values and how many documents were collapsed under under it. The field values are from the
+   *       collapse field and
+   *  <li> Debug information
+   * </ul>
+   *
+   * This method may only be invoked when the {@link this#collapse(Query, List, Sort)} has been invoked.
+   *
+   * @param searcher The solr index searcher
+   * @param docs     The doclist containing the results to be displayed
+   * @return collapse counts for all documents in the specified docList.
+   * @throws IOException if index searcher related problems occur
+   */
+  NamedList<Object> getCollapseInfo(SolrIndexSearcher searcher, DocList docs) throws IOException;
+
+}
Index: org/apache/solr/search/fieldcollapse/NonAdjacentDocumentCollapser.java
===================================================================
--- org/apache/solr/search/fieldcollapse/NonAdjacentDocumentCollapser.java	(revision 0)
+++ org/apache/solr/search/fieldcollapse/NonAdjacentDocumentCollapser.java	(revision 0)
@@ -0,0 +1,501 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.search.fieldcollapse;
+
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.search.*;
+import org.apache.lucene.util.PriorityQueue;
+import org.apache.solr.handler.component.ResponseBuilder;
+import org.apache.solr.search.DocIterator;
+import org.apache.solr.search.DocSet;
+import org.apache.solr.search.fieldcollapse.collector.CollapseCollector;
+import org.apache.solr.search.fieldcollapse.collector.CollapseCollectorFactory;
+import org.apache.solr.util.DocSetScoreCollector;
+
+import java.io.IOException;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+/**
+ * Normal collapsing behaviour. Collapses all documents that have the same field value on the predefined field
+ * and that have occured equal or more then collapse threshold.
+ */
+public class NonAdjacentDocumentCollapser extends AbstractDocumentCollapser {
+
+  DocumentComparator documentComparator;
+
+  /**
+   * See {@link super#AbstractDocumentCollapser(org.apache.solr.handler.component.ResponseBuilder, List)}
+   */
+  public NonAdjacentDocumentCollapser(ResponseBuilder rb, List<CollapseCollectorFactory> collapseCollectorFactories) throws IOException {
+    super(rb, collapseCollectorFactories);
+  }
+
+  /**
+   * {@inheritDoc}
+   */
+  @Override
+  protected void doQuery(Query mainQuery, List<Query> filterQueries, Sort sort) throws IOException {
+    final int maxDoc = searcher.maxDoc();
+    if (containsSortOnScore(sort)) {
+      DocSetScoreCollector docSetCollector = new DocSetScoreCollector(searcher.maxDoc());
+      long startTime = System.currentTimeMillis();
+      DocSet filter = searcher.getDocSet(filterQueries);
+      uncollapsedDocSet = searcher.getDocSet(mainQuery, filter, docSetCollector);
+      timeCreateUncollapedDocset = System.currentTimeMillis() - startTime;
+      if (sort == null) {
+        sort = new Sort(new SortField("score", SortField.SCORE, true));
+      }
+
+      float[] scores;
+      if (uncollapsedDocSet instanceof DocSetScoreCollector.DelegateDocSet) {
+        scores = ((DocSetScoreCollector.DelegateDocSet) uncollapsedDocSet).getScores();
+      } else {
+        scores = docSetCollector.getScores();
+      }
+      documentComparator = new DocumentComparator(sort, maxDoc, searcher.getIndexReader(), scores);
+    } else {
+      long startTime = System.currentTimeMillis();
+      DocSet filter = searcher.getDocSet(filterQueries);
+      uncollapsedDocSet = searcher.getDocSet(mainQuery, filter);
+      timeCreateUncollapedDocset = System.currentTimeMillis() - startTime;
+
+      documentComparator = new DocumentComparator(sort, maxDoc, searcher.getIndexReader());
+    }
+  }
+
+  /**
+   * {@inheritDoc}
+   */
+  protected void doCollapsing(DocSet uncollapsedDocset, FieldCache.StringIndex values) {
+    long startTime = System.currentTimeMillis();
+    int docCount = 0;
+    // Keep how many documents we have processed the track of how many docs
+    // with the same collapse value we have processed so far.
+    Map<String, CollapsedDocumentGroup> collapsedDocs = new HashMap<String, CollapsedDocumentGroup>();
+
+    for (DocIterator i  = uncollapsedDocset.iterator(); i.hasNext();) {
+      int currentId = i.nextDoc();
+      String currentValue = values.lookup[values.order[currentId]];
+
+      // Get the last doc. and the total amount of docs. we have seen so
+      // far for this collapsing value
+      CollapsedDocumentGroup collapseDoc = collapsedDocs.get(currentValue);
+      if (collapseDoc == null) {
+        // new collapsing value => create a new record for it
+        collapseDoc = new CollapsedDocumentGroup(0, 0, documentComparator, collapseThreshold);
+        collapsedDocs.put(currentValue, collapseDoc);
+      }
+      // dropoutId has a value smaller than the smallest value in the queue and therefore it was removed from the queue
+      Integer dropOutId = (Integer) collapseDoc.priorityQueue.insertWithOverflow(currentId);
+
+      // check if we have reached the collapse threshold, if so start counting collapsed documents
+      if (++collapseDoc.totalCount > collapseThreshold) {
+        collapseDoc.collapsedDocuments++;
+        if (dropOutId != null) {
+          NonAdjacentCollapseGroup collapseValue = new NonAdjacentCollapseGroup(currentValue);
+          for (CollapseCollector collector : collectors) {
+            collector.documentCollapsed(dropOutId, collapseValue, collapseContext);
+          }
+        }
+      }
+
+      // Stop after collapseMaxDocs documents
+      if (++docCount >= collapseMaxDocs) {
+        break;
+      }
+    }
+
+    // adding the head documents to the internal document buffer and
+    // adding the collapsed counts per document head to the map
+    for (String fieldValue : collapsedDocs.keySet()) {
+      CollapsedDocumentGroup collapseDoc = collapsedDocs.get(fieldValue);
+      if (collapseDoc.collapsedDocuments > 0) {
+        NonAdjacentCollapseGroup collapseValue = new NonAdjacentCollapseGroup(fieldValue);
+        for (CollapseCollector collector : collectors) {
+          collector.documentHead((Integer) collapseDoc.priorityQueue.top(), collapseValue, collapseContext);
+        }
+      }
+      Integer doc;
+      while ((doc = (Integer) collapseDoc.priorityQueue.pop()) != null) {
+        addDoc(doc);
+      }
+    }
+
+    timeCollapsing = System.currentTimeMillis() - startTime;
+  }
+
+
+  // ================================================= Helpers =========================================================
+
+  /**
+   * Returns <code>true</code> if the sort contains a sortfield that sorts on score, otherwise <code>false</code>.
+   *
+   * @param sort The sort
+   * @return <code>true</code> if the sort contains a sortfield that sorts on score, otherwise <code>false</code>
+   */
+  protected boolean containsSortOnScore(Sort sort) {
+    if (sort == null) {
+      return true; // means default sorting, which is sorting on score desc
+    }
+
+    for (SortField field : sort.getSort()) {
+      if (field.getType() == SortField.SCORE) {
+        return true;
+      }
+    }
+    return false;
+  }
+
+
+  // ============================================ Inner Classes ========================================================
+
+  private static class NonAdjacentCollapseGroup implements CollapseGroup {
+
+    private final String fieldValue;
+
+    private NonAdjacentCollapseGroup(String fieldValue) {
+      this.fieldValue = fieldValue;
+    }
+
+    public String getKey() {
+      return fieldValue;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+      if (this == o) return true;
+      if (o == null || getClass() != o.getClass()) return false;
+
+      NonAdjacentCollapseGroup that = (NonAdjacentCollapseGroup) o;
+
+      if (fieldValue != null ? !fieldValue.equals(that.fieldValue) : that.fieldValue != null) return false;
+
+      return true;
+    }
+
+    @Override
+    public int hashCode() {
+      return fieldValue != null ? fieldValue.hashCode() : 0;
+    }
+  }
+
+  /**
+   * A <code>PriorityQueue</code> that maintaince order with a <code>DocumentComparator</code>.
+   */
+  public static class DocumentPriorityQueue extends PriorityQueue {
+
+    private final DocumentComparator comparator;
+
+    /**
+     * Constructs a <code>DocumentPriorityQueue</code>
+     *
+     * @param comparator The <code>DocumentComparator</code> used for maintaining order in the queue
+     * @param max        The maximum number of document identifiers in the queue (is equal to collapse thresold paramter)
+     */
+    public DocumentPriorityQueue(DocumentComparator comparator, int max) {
+      this.comparator = comparator;
+      initialize(max);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    protected boolean lessThan(Object a, Object b) {
+      return comparator.compare((Integer) a, (Integer) b) < 0;
+    }
+  }
+
+  /**
+   * Compares two documents with each other.
+   */
+  public static class DocumentComparator {
+
+    private final FieldComparator[] fieldComparators;
+    private final boolean[] descending;
+    private Scorer scorer;
+
+    /**
+     * Constructs a <code>DocumentComparator</code> by initializing the
+     * {@link org.apache.lucene.search.FieldComparator}s and determining the sort orders.
+     *
+     * @param sort         The sort used for the creation of the FieldComparators.
+     * @param numberOfHits The number of results in the pre-field-collapsed resultset
+     * @param reader       The index reader, used for reading field values (in the FieldComparators)
+     */
+    public DocumentComparator(Sort sort, int numberOfHits, IndexReader reader) {
+      fieldComparators = new FieldComparator[sort.getSort().length];
+      descending = new boolean[sort.getSort().length];
+      initializeFieldComparators(sort, numberOfHits, reader, null);
+    }
+
+    /**
+     * Constructs a <code>DocumentComparator</code> by initializing the
+     * {@link org.apache.lucene.search.FieldComparator}s and determining the sort orders.
+     *
+     * @param sort         The sort used for the creation of the FieldComparators.
+     * @param numberOfHits The number of results in the pre-field-collapsed resultset
+     * @param reader       The index reader, used for reading field values (in the FieldComparators)
+     * @param scores       The scores used for comparing the documents
+     */
+    public DocumentComparator(Sort sort, int numberOfHits, IndexReader reader, float[] scores) {
+      fieldComparators = new FieldComparator[sort.getSort().length];
+      descending = new boolean[sort.getSort().length];
+      initializeFieldComparators(sort, numberOfHits, reader, scores);
+    }
+
+    /**
+     * Compares doc1 and doc2 with each other.
+     * Compares the two documents with the initialized <code>FieldComparators</code>,
+     * if all <code>FieldComparators</code> compares the documents as equal then the document with lowest lucene
+     * identifier will be classified as most relevant.
+     *
+     * @param doc1 The lucene identifier of the first document
+     * @param doc2 The lucene identifier of the second document
+     * @return -1 if doc1 is less relevant or equal relevant but has a higher lucene id then doc2,
+     *         0 if both documents are identical
+     *         1 if doc1 is more relevant or equal relevant but has a lower lucene id then doc2
+     */
+    public int compare(int doc1, int doc2) {
+      int result;
+      for (int i = 0; i < fieldComparators.length; i++) {
+        FieldComparator fieldComparator = fieldComparators[i];
+        try {
+          scorer.advance(doc1);
+          fieldComparator.copy(doc1, doc1);
+          scorer.advance(doc2);
+          fieldComparator.copy(doc2, doc2);
+        } catch (IOException e) {
+          throw new RuntimeException(e);
+        }
+        result = fieldComparator.compare(doc1, doc2);
+        result = descending[i] ? result : -result;
+
+        if (result != 0) {
+          return result;
+        }
+      }
+
+      // field comparators identified the field(s) values as equal
+      // Document with lowest identifier has higher precendence
+      if (doc1 < doc2) {
+        return 1;
+      } else if (doc1 > doc2) {
+        return -1;
+      }
+
+      // can only happen if comparing two the exact same document (with same lucene id)
+      return 0;
+    }
+
+    private void initializeFieldComparators(Sort sort, int numberOfHits, IndexReader indexReader, float[] scores) {
+      try {
+        scorer = new PredefinedScorer(scores == null ? new float[0] : scores);
+        if (sort.getSort().length == 1 && scores != null) {
+          fieldComparators[0] = new FloatValueFieldComparator(scores);
+          descending[0] = sort.getSort()[0].getReverse();
+          return;
+        }
+
+        for (int i = 0; i < sort.getSort().length; i++) {
+          SortField sortField = sort.getSort()[i];
+          fieldComparators[i] = sortField.getComparator(numberOfHits, i);
+          descending[i] = sortField.getReverse();
+          fieldComparators[i].setNextReader(indexReader, 0);
+          fieldComparators[i].setScorer(scorer);
+        }
+      } catch (IOException e) {
+        throw new RuntimeException(e);
+      }
+    }
+
+  }
+
+  /**
+   * Represents a collapse group, that collects statistics for a certain fieldvalue group.
+   * <p/>
+   * Keeps track of the following statistics during the collapsing on fieldvalue:
+   * <ul>
+   * <li>how many documents were collapsed
+   * <li>what the most relevant head documents are in this group (these will not get collapsed)
+   * <li>how many have been procesed
+   * </ul>
+   */
+  private static class CollapsedDocumentGroup {
+
+    int collapsedDocuments;
+    int totalCount;
+    final DocumentPriorityQueue priorityQueue;
+
+    /**
+     * Constructs a <code>CollapsedDocumentGroup</code>. Keeps track of the of the most relevant documents
+     * in this group. These documents will stay in the resultset and do not get collaped, no more then the
+     * specified collpasThreshold will be kept inside this <code>CollapsedDocumentGroup</code>.
+     *
+     * @param totalCount         the total amount documents processed in the collapsing process
+     * @param collapsedDocuments the amount of documents collapsed under this group
+     * @param comparator         The document comparater used inside priority queue
+     * @param collapsThreshold   The threshold to start collapsing from
+     */
+    private CollapsedDocumentGroup(int totalCount, int collapsedDocuments, DocumentComparator comparator, int collapsThreshold) {
+      this.totalCount = totalCount;
+      this.collapsedDocuments = collapsedDocuments;
+      this.priorityQueue = new DocumentPriorityQueue(comparator, collapsThreshold);
+    }
+  }
+
+  /**
+   * A scorer that returns scores from a predefined array of scores.
+   */
+  private static final class PredefinedScorer extends Scorer {
+
+    private final float[] scores;
+    private int index;
+
+    private PredefinedScorer(float[] scores) {
+      super(null);
+      this.scores = scores;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public float score() throws IOException {
+      return scores[index];
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public int docID() {
+      return index;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public int nextDoc() throws IOException {
+      return index < scores.length ? ++index : NO_MORE_DOCS;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public int advance(int target) throws IOException {
+      if (target < scores.length) {
+        index = target;
+        return index;
+      }
+      return NO_MORE_DOCS;
+    }
+
+  }
+
+  /**
+   * Field comparator for floats. This implementation is a little bit faster (around 30 ms) then {@link FloatComparator.FloatComparator}
+   * because it does not copy floats in {@link #copy(int, int)}. This is not necessary in fieldcollapsing case, because
+   * the arguments passed to the {@link #compare(int, int)} method are document ids and the values array is sorted on
+   * document order.
+   */
+  private static class FloatValueFieldComparator extends FieldComparator {
+
+    private final float[] values;
+
+    private FloatValueFieldComparator(float[] values) {
+      this.values = values;
+    }
+
+    /**
+     * Compares value for doc1 with value for doc2.
+     *
+     * @param doc1 first document to compare
+     * @param doc2 second document to compare
+     * @return any N < 0 if doc2's value is sorted after
+     *         doc1, any N > 0 if the doc2's value is sorted before
+     *         doc1 and 0 if they are equal
+     */
+    public int compare(int doc1, int doc2) {
+      final float value1 = values[doc1];
+      final float value2 = values[doc2];
+
+      if (value1 > value2) {
+        return 1;
+      } else if (value1 < value2) {
+        return -1;
+      } else {
+        return 0;
+      }
+    }
+
+    /**
+     * Unsupported, is not necessary for field collapsing
+     *
+     * @param doc The document identifier
+     * @throws UnsupportedOperationException
+     */
+    public void setBottom(int doc) {
+      throw new UnsupportedOperationException("Method not implemented");
+    }
+
+    /**
+     * Unsupported, is not necessary for field collapsing
+     *
+     * @param doc The document identifier
+     * @return nothing
+     * @throws UnsupportedOperationException
+     */
+    public int compareBottom(int doc) throws IOException {
+      throw new UnsupportedOperationException("Method not implemented");
+    }
+
+    /**
+     * {@inheritDoc}
+     * <br /><br />
+     * Does nothing, necessary to implement because of superclass.
+     */
+    public void copy(int slot, int doc) throws IOException {
+    }
+
+    /**
+     * {@inheritDoc}
+     * <br /><br />
+     * Does nothing, necessary to implement because of superclass.
+     */
+    public void setNextReader(IndexReader reader, int docBase) throws IOException {
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public int sortType() {
+      return SortField.FLOAT;
+    }
+
+    /**
+     * Unsupported, is not necessary for field collapsing
+     *
+     * @param doc The document identifier
+     * @throws UnsupportedOperationException
+     */
+    public Comparable value(int doc) {
+      throw new UnsupportedOperationException("Method not implemented");
+    }
+
+  }
+}
Index: org/apache/solr/search/fieldcollapse/collector/AbstractCollapseCollector.java
===================================================================
--- org/apache/solr/search/fieldcollapse/collector/AbstractCollapseCollector.java	(revision 0)
+++ org/apache/solr/search/fieldcollapse/collector/AbstractCollapseCollector.java	(revision 0)
@@ -0,0 +1,54 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.search.fieldcollapse.collector;
+
+import org.apache.solr.common.util.NamedList;
+import org.apache.solr.search.SolrIndexSearcher;
+
+import java.io.IOException;
+
+/**
+ *
+ */
+public abstract class AbstractCollapseCollector implements CollapseCollector {
+
+  protected final SolrIndexSearcher searcher;
+
+  protected AbstractCollapseCollector(SolrIndexSearcher searcher) {
+    this.searcher = searcher;
+  }
+
+
+  // ================================================= Helpers =======================================================
+
+  protected NamedList getCollapseGroupResult(int docId, NamedList result) {
+    String uniqueIdFieldname = searcher.getSchema().getUniqueKeyField().getName();
+    try {
+      String schemaId = searcher.doc(docId).get(uniqueIdFieldname);
+      NamedList collapseGroupResult = (NamedList) result.get(schemaId);
+      if (collapseGroupResult == null) {
+        collapseGroupResult = new NamedList();
+        result.add(schemaId, collapseGroupResult);
+      }
+
+      return collapseGroupResult;
+    } catch (IOException e) {
+      throw new RuntimeException(e);
+    }
+  }
+}
Index: org/apache/solr/search/fieldcollapse/collector/AggregateCollapseCollectorFactory.java
===================================================================
--- org/apache/solr/search/fieldcollapse/collector/AggregateCollapseCollectorFactory.java	(revision 0)
+++ org/apache/solr/search/fieldcollapse/collector/AggregateCollapseCollectorFactory.java	(revision 0)
@@ -0,0 +1,265 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.search.fieldcollapse.collector;
+
+import org.apache.lucene.search.FieldCache;
+import org.apache.solr.common.SolrException;
+import org.apache.solr.common.params.CollapseParams;
+import org.apache.solr.common.util.NamedList;
+import org.apache.solr.request.SolrQueryRequest;
+import org.apache.solr.schema.FieldType;
+import org.apache.solr.search.DocIterator;
+import org.apache.solr.search.DocList;
+import org.apache.solr.search.SolrIndexSearcher;
+import org.apache.solr.search.fieldcollapse.CollapseGroup;
+import org.apache.solr.search.fieldcollapse.collector.aggregate.*;
+import org.apache.solr.util.plugin.NamedListInitializedPlugin;
+
+import java.io.IOException;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+/**
+ * A collapse collector factory that creates collapse collectors that create aggregate statistics based on the collapsed
+ * documents.
+ *
+ * <p>
+ * If the <code>collapse.aggregate</code> is set with a string that describes what data to collect then a new collapse
+ * collector is created that collects this data.
+ *
+ * <p>
+ * The string should be formatted acording to the following format:
+ * [function name]([field name])[, ] ...
+ * Example: avg(price), max(stock), sum(stock)
+ *
+ * <p>
+ * When this collapse collector factory is configured this feature is <b>not</b> enabled by default.
+ */
+public class AggregateCollapseCollectorFactory implements CollapseCollectorFactory, NamedListInitializedPlugin {
+
+  private final static Pattern splitPattern = Pattern.compile(",");
+  private final static Pattern aggregatePattern = Pattern.compile("(.+)\\((.+)\\)");
+
+  private final Map<String, Class<? extends AggregateFunction>> aggregateFunctions = new HashMap<String, Class<? extends AggregateFunction>>();
+
+  @SuppressWarnings("unchecked")
+  public void init(NamedList args) {
+    NamedList<String> functionClassNames = (NamedList<String>) args.get("aggregateFunctions");
+    if (functionClassNames == null) {
+      aggregateFunctions.put("avg", AverageFunction.class);
+      aggregateFunctions.put("sum", SumFunction.class);
+      aggregateFunctions.put("min", MinFunction.class);
+      aggregateFunctions.put("max", MaxFunction.class);
+      return;
+    }
+
+    for (Map.Entry<String, String> entry : functionClassNames) {
+      Class<? extends AggregateFunction> functionClass;
+      try {
+        functionClass = (Class<? extends AggregateFunction>) Class.forName(entry.getValue());
+      } catch (ClassNotFoundException e) {
+        throw new RuntimeException(e);
+      }
+      aggregateFunctions.put(entry.getKey(), functionClass);
+    }
+  }
+
+  /**
+   * Returns an new collapse collector instance that creates aggregate statictics if the collapse.aggregate paramter
+   * is set.
+   *
+   * @param request The specified request
+   * @return an new collapse collector instance if the collapse.aggregate parameter is set properly
+   */
+  public CollapseCollector createCollapseCollector(SolrQueryRequest request) {
+    String aggregateParameterValue = request.getParams().get(CollapseParams.COLLAPSE_AGGREGATE);
+    if (aggregateParameterValue == null) {
+      return null;
+    }
+
+    Map<AggregateField, AggregateFunction> aggregateFunctions = resolveAggregateFunctions(aggregateParameterValue);
+    return new AggregateCollapseCollector(aggregateFunctions, request.getSearcher());
+  }
+
+  /**
+   * Resolves on a per field basis the aggregate function.
+   * <ul>
+   * <li> Splits the functions. E.g. collapse.aggregate=avg(price),sum(stock) into avg(price) and sum(stock)
+   * <li> Splits the functionname and fieldname from each function in order to resolve and instantiates the aggregate function.
+   * E.g. functionname = avg, fieldname = price
+   * <li> Looks up the function class and creates an instance of it.
+   * </ul>
+   *
+   * @param aggregateParameterValue The <code>collapse.aggregate</code> parameter value in the solr request
+   * @return an aggragate function per field stored in a map.
+   */
+  protected Map<AggregateField, AggregateFunction> resolveAggregateFunctions(String aggregateParameterValue) {
+    Map<AggregateField, AggregateFunction> fieldNameAggregateFunction = new HashMap<AggregateField, AggregateFunction>();
+
+    String[] aggregates = splitPattern.split(aggregateParameterValue);
+    for (String aggregate : aggregates) {
+      Matcher matcher = aggregatePattern.matcher(aggregate);
+      if (!matcher.matches() || matcher.groupCount() != 2) {
+        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, "Aggregate function syntax is incorrect.");
+      }
+
+      String functionName = matcher.group(1).trim();
+      String fieldName = matcher.group(2);
+      AggregateFunction function = resolveAggregateFunction(functionName);
+      fieldNameAggregateFunction.put(new AggregateField(fieldName, functionName), function);
+    }
+
+    return fieldNameAggregateFunction;
+  }
+
+  /**
+   * Returns a new instance of the <code>AggregateFunction</code> with the specified functionName.
+   *
+   * @param functionName The name of the function to create a new instance of
+   * @return a new instance of the <code>AggregateFunction</code> with the specified functionName
+   * @throws UnsupportedOperationException When no aggregate functions with the specified function name exists
+   */
+  protected AggregateFunction resolveAggregateFunction(String functionName) {
+    Class<? extends AggregateFunction> classOfFunction = aggregateFunctions.get(functionName);
+    if (classOfFunction == null) {
+      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, String.format("Aggregate function with name [%s] does not exist", functionName));
+    }
+
+    try {
+      return classOfFunction.newInstance();
+    } catch (InstantiationException e) {
+      throw new RuntimeException(e);
+    } catch (IllegalAccessException e) {
+      throw new RuntimeException(e);
+    }
+  }
+
+
+  //============================================== Inner classes =======================================================
+
+  private static class AggregateCollapseCollector extends AbstractCollapseCollector {
+
+    private final Map<AggregateField, AggregateFunction> functions;
+    private final Map<String, FieldCache.StringIndex> fieldCaches = new HashMap<String, FieldCache.StringIndex>();
+    private final Map<String, FieldType> fieldTypes = new HashMap<String, FieldType>();
+
+    private AggregateCollapseCollector(Map<AggregateField, AggregateFunction> functions, SolrIndexSearcher searcher) {
+      super(searcher);
+      this.functions = functions;
+
+      for (AggregateField aggregateField : functions.keySet()) {
+        try {
+          String fieldName = aggregateField.getFieldName();
+          fieldCaches.put(fieldName, FieldCache.DEFAULT.getStringIndex(searcher.getReader(), fieldName));
+          fieldTypes.put(fieldName, searcher.getSchema().getFieldType(fieldName));
+        } catch (IOException e) {
+          throw new RuntimeException(e);
+        }
+      }
+    }
+
+    public void documentCollapsed(int docId, CollapseGroup collapseGroup, CollapseContext collapseContext) {
+      for (AggregateField aggregateField : functions.keySet()) {
+        FieldCache.StringIndex stringIndex = fieldCaches.get(aggregateField.getFieldName());
+        AggregateFunction function = functions.get(aggregateField);
+
+        String fieldCacheValue = stringIndex.lookup[stringIndex.order[docId]];
+        String value = fieldTypes.get(aggregateField.getFieldName()).indexedToReadable(fieldCacheValue);
+        function.collect(collapseGroup, value);
+      }
+    }
+
+    public void documentHead(int docHeadId, CollapseGroup collapseGroup, CollapseContext collapseContext) {
+    }
+
+    public void getResult(NamedList result, DocList docs, CollapseContext collapseContext) {
+      Map<Integer, CollapseGroup> docHeadCollapseGroupAssoc = collapseContext.getDocumentHeadCollapseGroupAssociation();
+
+      for (DocIterator i = docs.iterator(); i.hasNext();) {
+          int id = i.nextDoc();
+          CollapseGroup collapseGroup = docHeadCollapseGroupAssoc.get(id);
+          if (collapseGroup == null) {
+            continue;
+          }
+
+          for (AggregateField aggregateField : functions.keySet()) {
+            AggregateFunction function = functions.get(aggregateField);
+            String functionResult = function.calculate(collapseGroup);
+            if (functionResult != null) {
+              NamedList collapsedGroupResult = getCollapseGroupResult(id, result);
+              NamedList aggragateFunctions = (NamedList) collapsedGroupResult.get("aggregate");
+              if (aggragateFunctions == null) {
+                aggragateFunctions = new NamedList<Object>();
+                collapsedGroupResult.add("aggregate", aggragateFunctions);
+              }
+
+              aggragateFunctions.add(aggregateField.getUniqueName(), functionResult);
+            }
+          }
+
+      }
+    }
+
+  }
+
+  private final static class AggregateField {
+
+    private final String fieldName;
+    private final String functionName;
+
+    private AggregateField(String fieldName, String functionName) {
+      this.fieldName = fieldName;
+      this.functionName = functionName;
+    }
+
+    public String getFieldName() {
+      return fieldName;
+    }
+
+    public String getFunctionName() {
+      return functionName;
+    }
+
+    public String getUniqueName() {
+      return String.format("%s(%s)", functionName, fieldName);
+    }
+
+    @Override
+    public boolean equals(Object o) {
+      if (this == o) return true;
+      if (o == null || getClass() != o.getClass()) return false;
+
+      AggregateField that = (AggregateField) o;
+
+      if (fieldName != null ? !fieldName.equals(that.fieldName) : that.fieldName != null) return false;
+      if (functionName != null ? !functionName.equals(that.functionName) : that.functionName != null) return false;
+
+      return true;
+    }
+
+    @Override
+    public int hashCode() {
+      int result = fieldName != null ? fieldName.hashCode() : 0;
+      result = 31 * result + (functionName != null ? functionName.hashCode() : 0);
+      return result;
+    }
+  }
+
+}
Index: org/apache/solr/search/fieldcollapse/collector/CollapseCollector.java
===================================================================
--- org/apache/solr/search/fieldcollapse/collector/CollapseCollector.java	(revision 0)
+++ org/apache/solr/search/fieldcollapse/collector/CollapseCollector.java	(revision 0)
@@ -0,0 +1,61 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.search.fieldcollapse.collector;
+
+import org.apache.solr.common.util.NamedList;
+import org.apache.solr.search.DocList;
+import org.apache.solr.search.fieldcollapse.CollapseGroup;
+
+/**
+ * A <code>CollapseCollector</code> is responsible for receiving collapse callbacks from the <code>DocumentCollapser</code>.
+ * An implementation can choose what to do with the received callbacks and data. Whatever an implementation collects it
+ * is responsible for adding its results to the response.
+ *
+ * Implementation of this interface don't need to be thread safe!
+ */
+public interface CollapseCollector {
+
+  /**
+   * Informs the <code>CollapseCollector</code> that a document has been collapsed under the specified collapseGroup.
+   *
+   * @param docId The id of the document that has been collasped
+   * @param collapseGroup The collapse group the docId has been collapsed under
+   * @param collapseContext The collapse context
+   */
+  void documentCollapsed(int docId, CollapseGroup collapseGroup, CollapseContext collapseContext);
+
+  /**
+   * Informs the <code>CollapseCollector</code> about the document head.
+   * The document head is the most relevant id for the specified collapseGroup.
+   *
+   * @param docHeadId The identifier of the document head
+   * @param collapseGroup The collapse group of the document head
+   * @param collapseContext The collapse context
+   */
+  void documentHead(int docHeadId, CollapseGroup collapseGroup, CollapseContext collapseContext);
+
+  /**
+   * Adds the <code>CollapseCollector</code> implementation specific result data to the result.
+   *
+   * @param result The response result 
+   * @param docs The documents to be added to the response
+   * @param collapseContext The collapse context
+   */
+  void getResult(NamedList result, DocList docs, CollapseContext collapseContext);
+
+}
Index: org/apache/solr/search/fieldcollapse/collector/CollapseCollectorFactory.java
===================================================================
--- org/apache/solr/search/fieldcollapse/collector/CollapseCollectorFactory.java	(revision 0)
+++ org/apache/solr/search/fieldcollapse/collector/CollapseCollectorFactory.java	(revision 0)
@@ -0,0 +1,38 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.search.fieldcollapse.collector;
+
+import org.apache.solr.request.SolrQueryRequest;
+
+/**
+ * A concrete <code>CollapseCollectorFactory</code> implementation is responsible for creating {@link CollapseCollector}
+ * instances based on the {@link SolrQueryRequest}.
+ */
+public interface CollapseCollectorFactory {
+
+  /**
+   * Creates an instance of a CollapseCollector specified by the concrete subclass.
+   * The concrete subclass decides based on the specified request if an new instance has to be created and
+   * can return <code>null</code> for that matter.
+   * 
+   * @param request The specified request
+   * @return an instance of a CollapseCollector or <code>null</code>
+   */
+  CollapseCollector createCollapseCollector(SolrQueryRequest request);
+
+}
Index: org/apache/solr/search/fieldcollapse/collector/CollapseContext.java
===================================================================
--- org/apache/solr/search/fieldcollapse/collector/CollapseContext.java	(revision 0)
+++ org/apache/solr/search/fieldcollapse/collector/CollapseContext.java	(revision 0)
@@ -0,0 +1,72 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.search.fieldcollapse.collector;
+
+import org.apache.solr.search.fieldcollapse.CollapseGroup;
+
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * A collapse context allows <code>CollapseCollectors</code> to share data between each other.
+ * Per search request only one <code>CollapseContext</code> will be created.
+ * A <code>CollapseContext</code> is <b>not</b> thread save.
+ */
+public class CollapseContext {
+
+  private static final String DOCUMENT_HEAD_COLLAPSE_GROUP_ASSOCIATION_KEY = "documentHeadCollapseGroupAssociation";
+
+  private final Map<String, Object> data = new HashMap<String, Object>();
+
+  public CollapseContext() {
+    data.put(DOCUMENT_HEAD_COLLAPSE_GROUP_ASSOCIATION_KEY, new HashMap<Integer, CollapseGroup>());
+  }
+
+  /**
+   * Sets a value in the collapse context under the specified key.
+   *
+   * @param key The key
+   * @param value The value to share
+   */
+  public void put(String key, Object value) {
+    data.put(key, value);
+  }
+
+  /**
+   * Returns a value in the collapse context that is associated with the specified key or <code>null</code> if
+   * no value is associated with the specified key.
+   *
+   * @param key The key
+   * @return a value in the collapse or <code>null</code>
+   */
+  public Object get(String key) {
+    return data.get(key);
+  }
+
+  /**
+   * Returns the documenthead collapse group association.
+   * The documenthead collapse group association is a map with the document head as key and the collapse group as value.
+   * This method never returns a <code>null</code> value.
+   *
+   * @return the documenthead collapse group association
+   */
+  public Map<Integer, CollapseGroup> getDocumentHeadCollapseGroupAssociation() {
+    return (Map<Integer, CollapseGroup>) data.get(DOCUMENT_HEAD_COLLAPSE_GROUP_ASSOCIATION_KEY);
+  }
+
+}
Index: org/apache/solr/search/fieldcollapse/collector/DocumentFieldsCollapseCollectorFactory.java
===================================================================
--- org/apache/solr/search/fieldcollapse/collector/DocumentFieldsCollapseCollectorFactory.java	(revision 0)
+++ org/apache/solr/search/fieldcollapse/collector/DocumentFieldsCollapseCollectorFactory.java	(revision 0)
@@ -0,0 +1,147 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.search.fieldcollapse.collector;
+
+import org.apache.lucene.document.Document;
+import org.apache.lucene.document.Fieldable;
+import org.apache.lucene.search.DocIdSetIterator;
+import org.apache.lucene.util.OpenBitSet;
+import org.apache.solr.common.SolrDocument;
+import org.apache.solr.common.SolrDocumentList;
+import org.apache.solr.common.params.CollapseParams;
+import org.apache.solr.common.params.SolrParams;
+import org.apache.solr.common.util.NamedList;
+import org.apache.solr.request.SolrQueryRequest;
+import org.apache.solr.schema.IndexSchema;
+import org.apache.solr.search.DocIterator;
+import org.apache.solr.search.DocList;
+import org.apache.solr.search.SolrIndexSearcher;
+import org.apache.solr.search.fieldcollapse.CollapseGroup;
+import org.apache.solr.update.DocumentBuilder;
+
+import java.io.IOException;
+import java.util.*;
+import java.util.regex.Pattern;
+
+/**
+ * A collector factory that creates collapse collectors that collect predefined fieldvalues from collapsed documents.
+ * In order to enable this specify collapse.includeCollapsedDocs.fl=[val] in the request. Where [val] may be a star (*)
+ * to include all field of the collapsed documents or a comma separated list of the collapsed documents' fieldnames to include.
+ * When configured this feature is <b>not</b> enabled by default. 
+ */
+public class DocumentFieldsCollapseCollectorFactory implements CollapseCollectorFactory {
+
+  private static final Pattern splitPattern = Pattern.compile(",");
+
+  /**
+   * {@inheritDoc}
+   */
+  public CollapseCollector createCollapseCollector(SolrQueryRequest request) {
+    SolrParams params = request.getParams();
+    String collapsedDocumentFields = params.get(CollapseParams.COLLAPSE_INCLUDE_COLLAPSED_DOCS_FIELDS);
+    if (collapsedDocumentFields == null || "".equals(collapsedDocumentFields.trim())) {
+      return null;
+    }
+
+    Set<String> fields;
+    if ("*".equals(collapsedDocumentFields.trim())) {
+      fields = null;
+    } else {
+      fields = new HashSet<String>(Arrays.asList(splitPattern.split(collapsedDocumentFields)));
+    }
+
+    return new CollapsedDocumentCollapseCollector(request.getSearcher(), fields);
+  }
+
+
+  //============================================== Inner classes =======================================================
+
+  private static class CollapsedDocumentCollapseCollector extends AbstractCollapseCollector {
+
+    private final Map<CollapseGroup, OpenBitSet> collapsedDocumentsByFieldValue = new HashMap<CollapseGroup, OpenBitSet>();
+    private final Set<String> includeCollapsedDocumentsFields;
+
+    public CollapsedDocumentCollapseCollector(SolrIndexSearcher searcher, Set<String> fields) {
+      super(searcher);
+      this.includeCollapsedDocumentsFields = fields;
+    }
+
+    public void documentCollapsed(int docId, CollapseGroup collapseGroup, CollapseContext collapseContext) {
+      OpenBitSet bitSet = collapsedDocumentsByFieldValue.get(collapseGroup);
+      if (bitSet == null) {
+        collapsedDocumentsByFieldValue.put(collapseGroup, bitSet = new OpenBitSet());
+      }
+      // We cannot use fastset because we do not know the size upfront.
+      // The set method is more expensive than fastset, but that is the best for now.
+      // Setting bitSet to maxDoc may increase the memory footprint dramatically, because for each distinct fieldvalue
+      // there is a bitset
+      bitSet.set(docId);
+    }
+
+    public void documentHead(int docHeadId, CollapseGroup collapseGroup, CollapseContext collapseContext) {
+    }
+
+    @SuppressWarnings("unchecked")
+    public void getResult(NamedList result, DocList docs, CollapseContext collapseContext) {
+      IndexSchema schema = searcher.getSchema();
+      DocumentBuilder documentBuilder = new DocumentBuilder(schema);
+      Map<Integer, CollapseGroup> docHeadCollapseGroupAssoc = collapseContext.getDocumentHeadCollapseGroupAssociation();
+
+      try {
+        for (DocIterator i = docs.iterator(); i.hasNext();) {
+          int id = i.nextDoc();
+          if (!docHeadCollapseGroupAssoc.containsKey(id)) {
+            continue;
+          }
+
+          CollapseGroup collapseGroup = docHeadCollapseGroupAssoc.get(id);
+          OpenBitSet bitSet = collapsedDocumentsByFieldValue.get(collapseGroup);
+          SolrDocumentList documentList = new SolrDocumentList();
+          for (DocIdSetIterator iterator = bitSet.iterator(); iterator.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;) {
+            Document luceneDocument = searcher.doc(iterator.docID(), includeCollapsedDocumentsFields);
+
+            // the luceneDocument may still contain fields that are not specified in the includeCollapsedDocumentsFields
+            // this is because the document was read from the document cache. Off course we only want to return requested the fields.
+            // There is also another doc() method that accepts a FieldSelector instead of a list of fields, but that
+            // method does not use the Solr document cache, which from my perspective is a necessity
+            if (includeCollapsedDocumentsFields != null && luceneDocument.getFields().size() > includeCollapsedDocumentsFields.size()) {
+              Document document = new Document();
+              for (Object object : luceneDocument.getFields()) {
+                Fieldable field = (Fieldable) object;
+                if (includeCollapsedDocumentsFields.contains(field.name())) {
+                  document.add(field);
+                }
+              }
+              luceneDocument = document;
+            }
+
+            SolrDocument solrDocument = new SolrDocument();
+            documentBuilder.loadStoredFields(solrDocument, luceneDocument);
+            documentList.add(solrDocument);
+          }
+          documentList.setNumFound(bitSet.cardinality());
+          NamedList collapsedGroupResult = getCollapseGroupResult(id, result);
+          collapsedGroupResult.add("collapsedDocs", documentList);
+        }
+      } catch (IOException e) {
+        throw new RuntimeException(e);
+      }
+    }
+  }
+
+}
Index: org/apache/solr/search/fieldcollapse/collector/DocumentGroupCountCollapseCollectorFactory.java
===================================================================
--- org/apache/solr/search/fieldcollapse/collector/DocumentGroupCountCollapseCollectorFactory.java	(revision 0)
+++ org/apache/solr/search/fieldcollapse/collector/DocumentGroupCountCollapseCollectorFactory.java	(revision 0)
@@ -0,0 +1,90 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.search.fieldcollapse.collector;
+
+import org.apache.solr.common.params.CollapseParams;
+import org.apache.solr.common.params.SolrParams;
+import org.apache.solr.common.util.NamedList;
+import org.apache.solr.request.SolrQueryRequest;
+import org.apache.solr.search.DocIterator;
+import org.apache.solr.search.DocList;
+import org.apache.solr.search.SolrIndexSearcher;
+import org.apache.solr.search.fieldcollapse.CollapseGroup;
+import org.apache.solr.search.fieldcollapse.util.Counter;
+
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * A collapse collector factory that creates collapse collectors that the collapse counts per document group and
+ * return the counts in the response per collapsed group most relevant document id.
+ * When this collapse collector factory is configured then this feature is enabled by default.
+ * To disable this for a search add collapse.info.doc=false in the request.
+ */
+public class DocumentGroupCountCollapseCollectorFactory implements CollapseCollectorFactory {
+
+  /**
+   * {@inheritDoc}
+   */
+  public CollapseCollector createCollapseCollector(SolrQueryRequest request) {
+    SolrParams params = request.getParams();
+    boolean includeDocCount = params.getBool(CollapseParams.COLLAPSE_INFO_DOC, true);
+    return includeDocCount ? new DocumentCountCollapseCollector(request.getSearcher()) : null;
+  }
+
+
+  //============================================== Inner classes =======================================================
+
+  private static class DocumentCountCollapseCollector extends AbstractCollapseCollector {
+
+    private final Map<CollapseGroup, Counter> fieldValueCount = new HashMap<CollapseGroup, Counter>();
+    private final Map<Integer, Counter> documentHeadCount = new HashMap<Integer, Counter>();
+
+    public DocumentCountCollapseCollector(SolrIndexSearcher searcher) {
+      super(searcher);
+    }
+
+    public void documentCollapsed(int docId, CollapseGroup collapseGroup, CollapseContext collapseContext) {
+      Counter counter = fieldValueCount.get(collapseGroup);
+      if (counter == null) {
+        counter = new Counter(0);
+        fieldValueCount.put(collapseGroup, counter);
+      }
+      counter.increment();
+    }
+
+    public void documentHead(int docHeadId, CollapseGroup collapseGroup, CollapseContext collapseContext) {
+      documentHeadCount.put(docHeadId, fieldValueCount.get(collapseGroup));
+      collapseContext.put("documentHeadCount", documentHeadCount);
+    }
+
+    public void getResult(NamedList result, DocList docs, CollapseContext collapseContext) {
+      for (DocIterator i = docs.iterator(); i.hasNext();) {
+        int id = i.nextDoc();
+        Counter counter = documentHeadCount.get(id);
+        if (counter == null) {
+          continue;
+        }
+
+        NamedList collapsedGroupResult = getCollapseGroupResult(id, result);
+        collapsedGroupResult.add("collapseCount", counter.getCount());
+      }
+    }
+  }
+
+}
Index: org/apache/solr/search/fieldcollapse/collector/FieldValueCountCollapseCollectorFactory.java
===================================================================
--- org/apache/solr/search/fieldcollapse/collector/FieldValueCountCollapseCollectorFactory.java	(revision 0)
+++ org/apache/solr/search/fieldcollapse/collector/FieldValueCountCollapseCollectorFactory.java	(revision 0)
@@ -0,0 +1,95 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.search.fieldcollapse.collector;
+
+import org.apache.solr.common.params.CollapseParams;
+import org.apache.solr.common.params.SolrParams;
+import org.apache.solr.common.util.NamedList;
+import org.apache.solr.request.SolrQueryRequest;
+import org.apache.solr.schema.FieldType;
+import org.apache.solr.schema.IndexSchema;
+import org.apache.solr.search.DocIterator;
+import org.apache.solr.search.DocList;
+import org.apache.solr.search.SolrIndexSearcher;
+import org.apache.solr.search.fieldcollapse.CollapseGroup;
+import org.apache.solr.search.fieldcollapse.util.Counter;
+
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * A collapse collector factory that creates collapse collectors that collect t the collapse count per collapsed group
+ * and return the counts in the response per collepsed group field value. When this collapse collector factory is
+ * configured it is enabled by default. To disable this feature for a certain search add collapse.info.count=false
+ * to the request as parameter.
+ */
+public class FieldValueCountCollapseCollectorFactory implements CollapseCollectorFactory {
+
+  /**
+   * {@inheritDoc}
+   */
+  public CollapseCollector createCollapseCollector(SolrQueryRequest request) {
+    SolrParams params = request.getParams();
+    String collapseField = params.required().get(CollapseParams.COLLAPSE_FIELD);
+    boolean includeFieldValueCount = params.getBool(CollapseParams.COLLAPSE_INFO_COUNT, true);
+    return includeFieldValueCount ? new FieldValueCountCollapseCollector(request.getSearcher(), collapseField) : null;
+  }
+
+
+  //============================================== Inner classes =======================================================
+
+  private static class FieldValueCountCollapseCollector extends AbstractCollapseCollector {
+
+    private final FieldType collapseFieldType;
+    private final Map<CollapseGroup, Counter> fieldValueCount = new HashMap<CollapseGroup, Counter>();
+
+    public FieldValueCountCollapseCollector(SolrIndexSearcher searcher, String collapseField) {
+      super(searcher);
+      IndexSchema schema = searcher.getSchema();
+      collapseFieldType = schema.getField(collapseField).getType();
+    }
+
+    public void documentCollapsed(int docId, CollapseGroup collapseGroup, CollapseContext collapseContext) {
+      Counter counter = fieldValueCount.get(collapseGroup);
+      if (counter == null) {
+        counter = new Counter(0);
+        fieldValueCount.put(collapseGroup, counter);
+      }
+      counter.increment();
+    }
+
+    public void documentHead(int docHeadId, CollapseGroup collapseGroup, CollapseContext collapseContext) {
+    }
+
+    public void getResult(NamedList result, DocList docs, CollapseContext collapseContext) {
+      Map<Integer, CollapseGroup> docHeadCollapseGroupAssoc = collapseContext.getDocumentHeadCollapseGroupAssociation();
+      for (DocIterator i = docs.iterator(); i.hasNext();) {
+        int id = i.nextDoc();
+        CollapseGroup collapseGroup = docHeadCollapseGroupAssoc.get(id);
+        if (collapseGroup == null) {
+          continue;
+        }
+
+        NamedList collapsedGroupResult = getCollapseGroupResult(id, result);
+        String fieldValue = collapseFieldType.indexedToReadable(collapseGroup.getKey());
+        collapsedGroupResult.add("fieldValue", fieldValue);
+      }
+    }
+
+  }
+}
Index: org/apache/solr/search/fieldcollapse/collector/aggregate/AggregateFunction.java
===================================================================
--- org/apache/solr/search/fieldcollapse/collector/aggregate/AggregateFunction.java	(revision 0)
+++ org/apache/solr/search/fieldcollapse/collector/aggregate/AggregateFunction.java	(revision 0)
@@ -0,0 +1,52 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.search.fieldcollapse.collector.aggregate;
+
+import org.apache.solr.search.fieldcollapse.CollapseGroup;
+
+/**
+ * A concrete aggregate function implementation is responsible for calculating the aggregated information and is used
+ * by {@link org.apache.solr.search.fieldcollapse.collector.AggregateCollapseCollectorFactory}
+ * and its <code>CollapseCollector</code> to provide the aggregated data.
+ */
+public interface AggregateFunction {
+
+  /**
+   * Adds the specified number that a list of other numbers that are associated with the specified field (group)
+   *
+   * @param collapseGroup The field value (group) to add the number to.
+   * @param number The number to add
+   */
+  void collect(CollapseGroup collapseGroup, String number);
+
+  /**
+   * Returns the string representation of the calculated aggregate for the specified collapseGroup.
+   *
+   * @param collapseGroup The collapse group to calculate the aggragate data for.
+   * @return the calculated aggregates per field value (group)
+   */
+  String calculate(CollapseGroup collapseGroup);
+
+  /**
+   * Returns the name of the function.
+   *
+   * @return the name of the function
+   */
+  String getName();
+
+}
Index: org/apache/solr/search/fieldcollapse/collector/aggregate/AverageFunction.java
===================================================================
--- org/apache/solr/search/fieldcollapse/collector/aggregate/AverageFunction.java	(revision 0)
+++ org/apache/solr/search/fieldcollapse/collector/aggregate/AverageFunction.java	(revision 0)
@@ -0,0 +1,64 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.search.fieldcollapse.collector.aggregate;
+
+import org.apache.solr.search.fieldcollapse.CollapseGroup;
+import org.apache.solr.search.fieldcollapse.util.Counter;
+
+import java.math.BigDecimal;
+import java.math.RoundingMode;
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * Computes the average (Arithmetic mean) of per collapse group.
+ */
+public class AverageFunction implements AggregateFunction {
+
+  private final Map<CollapseGroup, BigDecimal> sums = new HashMap<CollapseGroup, BigDecimal>();
+  private final Map<CollapseGroup, Counter> times = new HashMap<CollapseGroup, Counter>();
+
+  public void collect(CollapseGroup collapseGroup, String value) {
+    BigDecimal number = sums.get(collapseGroup);
+    if (number == null) {
+      sums.put(collapseGroup, new BigDecimal(value));
+      times.put(collapseGroup, new Counter(1));
+    } else {
+      number = number.add(new BigDecimal(value));
+      sums.put(collapseGroup, number);
+      times.get(collapseGroup).increment();
+    }
+  }
+
+  public String calculate(CollapseGroup collapseGroup) {
+    BigDecimal number = sums.get(collapseGroup);
+    if (number == null) {
+      return null;
+    }
+
+    int nrOfOccurences = times.get(collapseGroup).getCount();
+    // TODO: need to find a way to specify the scale via the request
+    BigDecimal result = number.divide(new BigDecimal(nrOfOccurences), 2, RoundingMode.HALF_UP);
+    return result.toString();
+  }
+
+  public String getName() {
+    return "avg";
+  }
+
+}
Index: org/apache/solr/search/fieldcollapse/collector/aggregate/MaxFunction.java
===================================================================
--- org/apache/solr/search/fieldcollapse/collector/aggregate/MaxFunction.java	(revision 0)
+++ org/apache/solr/search/fieldcollapse/collector/aggregate/MaxFunction.java	(revision 0)
@@ -0,0 +1,52 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.search.fieldcollapse.collector.aggregate;
+
+import org.apache.solr.search.fieldcollapse.CollapseGroup;
+
+import java.math.BigDecimal;
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * Computes the higest value per collapse group.
+ */
+public class MaxFunction implements AggregateFunction {
+
+   private final Map<CollapseGroup, BigDecimal> higestNumbers = new HashMap<CollapseGroup, BigDecimal>();
+
+  public void collect(CollapseGroup collapseGroup, String number) {
+    BigDecimal higestNumber = higestNumbers.get(collapseGroup);
+    BigDecimal newNumber = new BigDecimal(number);
+    if (higestNumber == null) {
+      higestNumbers.put(collapseGroup, newNumber);
+    } else {
+      higestNumbers.put(collapseGroup, higestNumber.max(newNumber));
+    }
+  }
+
+  public String calculate(CollapseGroup collapseGroup) {
+    BigDecimal higestNumber = higestNumbers.get(collapseGroup);
+    return higestNumber != null ? higestNumber.toString() : null;
+  }
+
+  public String getName() {
+    return "max";
+  }
+
+}
Index: org/apache/solr/search/fieldcollapse/collector/aggregate/MinFunction.java
===================================================================
--- org/apache/solr/search/fieldcollapse/collector/aggregate/MinFunction.java	(revision 0)
+++ org/apache/solr/search/fieldcollapse/collector/aggregate/MinFunction.java	(revision 0)
@@ -0,0 +1,52 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.search.fieldcollapse.collector.aggregate;
+
+import org.apache.solr.search.fieldcollapse.CollapseGroup;
+
+import java.math.BigDecimal;
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * Computes the lowest value per collapse group.
+ */
+public class MinFunction implements AggregateFunction {
+
+  private final Map<CollapseGroup, BigDecimal> lowestNumbers = new HashMap<CollapseGroup, BigDecimal>();
+
+  public void collect(CollapseGroup collapseGroup, String number) {
+    BigDecimal lowestNumber = lowestNumbers.get(collapseGroup);
+    BigDecimal newNumber = new BigDecimal(number);
+    if (lowestNumber == null) {
+      lowestNumbers.put(collapseGroup, newNumber);
+    } else {
+      lowestNumbers.put(collapseGroup, lowestNumber.min(newNumber));
+    }
+  }
+
+  public String calculate(CollapseGroup collapseGroup) {
+    BigDecimal lowestNumber = lowestNumbers.get(collapseGroup);
+    return lowestNumber != null ? lowestNumber.toString() : null;
+  }
+
+  public String getName() {
+    return "min";
+  }
+
+}
Index: org/apache/solr/search/fieldcollapse/collector/aggregate/SumFunction.java
===================================================================
--- org/apache/solr/search/fieldcollapse/collector/aggregate/SumFunction.java	(revision 0)
+++ org/apache/solr/search/fieldcollapse/collector/aggregate/SumFunction.java	(revision 0)
@@ -0,0 +1,54 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.search.fieldcollapse.collector.aggregate;
+
+import org.apache.solr.search.fieldcollapse.CollapseGroup;
+
+import java.math.BigDecimal;
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * Computes the sum of all nummeric values per collapse group.
+ */
+public class SumFunction implements AggregateFunction {
+
+  private final Map<CollapseGroup, BigDecimal> numbers = new HashMap<CollapseGroup, BigDecimal>();
+
+  public SumFunction() {
+  }
+
+  public void collect(CollapseGroup collapseGroup, String value) {
+    BigDecimal number = numbers.get(collapseGroup);
+    if (number == null) {
+      numbers.put(collapseGroup, new BigDecimal(value));
+    } else {
+      number = number.add(new BigDecimal(value));
+      numbers.put(collapseGroup, number);
+    }
+  }
+
+  public String calculate(CollapseGroup collapseGroup) {
+    Number number = numbers.get(collapseGroup);
+    return number != null ? number.toString() : null;
+  }
+
+  public String getName() {
+    return "sum";
+  }
+}
Index: org/apache/solr/search/fieldcollapse/util/Counter.java
===================================================================
--- org/apache/solr/search/fieldcollapse/util/Counter.java	(revision 0)
+++ org/apache/solr/search/fieldcollapse/util/Counter.java	(revision 0)
@@ -0,0 +1,72 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.search.fieldcollapse.util;
+
+/**
+ * A simple counter. In some parts of the field collapse code I need to keep track of the count. If I use an Integer for
+ * that I have the contant overhead of autoboxing and the creation of new Integer objects when I increment a counter.
+ * This class does not have that overhead because I increment the same variable.
+ * <p>
+ * This class is <b>not</b> thread safe.
+ */
+public class Counter {
+
+  private int count;
+
+  /**
+   * Constructs a counter with count value zero.
+   */
+  public Counter() {
+    this(0);
+  }
+
+  /**
+   * Constructs a counter with the specified count.
+   *
+   * @param count The specified count
+   */
+  public Counter(int count) {
+    this.count = count;
+  }
+
+  /**
+   * Increments the counter.
+   */
+  public void increment() {
+    count++;
+  }
+
+  /**
+   * Sets the counter to the specified count
+   *
+   * @param count The specified count
+   */
+  public void setCount(int count) {
+    this.count = count;
+  }
+
+  /**
+   * Returns the current count of this counter.
+   *
+   * @return the current count
+   */
+  public int getCount() {
+    return count;
+  }
+
+}
Index: org/apache/solr/search/DocSetAwareCollector.java
===================================================================
--- org/apache/solr/search/DocSetAwareCollector.java	(revision 0)
+++ org/apache/solr/search/DocSetAwareCollector.java	(revision 0)
@@ -0,0 +1,34 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.solr.search;
+
+import org.apache.lucene.search.Collector;
+
+/**
+ * A collecter that is DocSet aware.
+ * When the search has been performed, the collected documents can be retrieved in the form of a DocSet.
+ */
+public abstract class DocSetAwareCollector extends Collector {
+
+  /**
+   * Returns the collected documents in a DocSet.
+   *
+   * @return the collected documents
+   */
+  public abstract DocSet getDocSet();
+
+}
Index: org/apache/solr/core/CoreContainer.java
===================================================================
--- org/apache/solr/core/CoreContainer.java	(revision 885060)
+++ org/apache/solr/core/CoreContainer.java	(working copy)
@@ -17,41 +17,32 @@
 
 package org.apache.solr.core;
 
-import java.io.BufferedWriter;
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import java.io.OutputStreamWriter;
-import java.io.Writer;
-import java.io.InputStream;
-import java.nio.channels.FileChannel;
-import java.util.*;
-import java.util.concurrent.ConcurrentHashMap;
-import java.text.SimpleDateFormat;
-
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import javax.xml.parsers.ParserConfigurationException;
-import javax.xml.xpath.XPathConstants;
-import javax.xml.xpath.XPath;
-import javax.xml.xpath.XPathExpressionException;
-
+import org.apache.commons.io.IOUtils;
 import org.apache.solr.common.SolrException;
 import org.apache.solr.common.params.CoreAdminParams;
 import org.apache.solr.common.util.DOMUtil;
-import org.apache.solr.common.util.XML;
-import org.apache.solr.common.util.StrUtils;
 import org.apache.solr.common.util.FileUtils;
+import org.apache.solr.common.util.StrUtils;
+import org.apache.solr.common.util.XML;
 import org.apache.solr.handler.admin.CoreAdminHandler;
 import org.apache.solr.schema.IndexSchema;
-import org.apache.commons.io.IOUtils;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 import org.w3c.dom.Node;
 import org.w3c.dom.NodeList;
 import org.xml.sax.SAXException;
 
+import javax.xml.parsers.ParserConfigurationException;
+import javax.xml.xpath.XPath;
+import javax.xml.xpath.XPathConstants;
+import javax.xml.xpath.XPathExpressionException;
+import java.io.*;
+import java.nio.channels.FileChannel;
+import java.text.SimpleDateFormat;
+import java.util.*;
+import java.util.concurrent.ConcurrentHashMap;
 
+
 /**
  * @version $Id$
  * @since solr 1.3
@@ -87,6 +78,7 @@
   // Helper class to initialize the CoreContainer
   public static class Initializer {
     protected String solrConfigFilename = null;
+    protected String indexSchemaFilename = null;
     protected boolean abortOnConfigurationError = true;
 
     public boolean isAbortOnConfigurationError() {
@@ -105,6 +97,10 @@
       this.solrConfigFilename = solrConfigFilename;
     }
 
+    public void setIndexSchemaFilename(String indexSchemaFilename) {
+      this.indexSchemaFilename = indexSchemaFilename;
+    }
+
     // core container instantiation
     public CoreContainer initialize() throws IOException, ParserConfigurationException, SAXException {
       CoreContainer cores = null;
@@ -134,7 +130,8 @@
         SolrConfig cfg = solrConfigFilename == null ?
                 new SolrConfig(resourceLoader, SolrConfig.DEFAULT_CONF_FILE,null) :
                 new SolrConfig(resourceLoader, solrConfigFilename,null);
-        SolrCore singlecore = new SolrCore(null, null, cfg, null, dcore);
+        IndexSchema schema = indexSchemaFilename != null ? new IndexSchema(cfg, indexSchemaFilename, null) : null;
+        SolrCore singlecore = new SolrCore(null, null, cfg, schema, dcore);
         abortOnConfigurationError = cfg.getBool(
                 "abortOnConfigurationError", abortOnConfigurationError);
         cores.register("", singlecore, false);
Index: org/apache/solr/core/SolrConfig.java
===================================================================
--- org/apache/solr/core/SolrConfig.java	(revision 885060)
+++ org/apache/solr/core/SolrConfig.java	(working copy)
@@ -17,43 +17,40 @@
 
 package org.apache.solr.core;
 
+import org.apache.lucene.index.IndexDeletionPolicy;
+import org.apache.lucene.search.BooleanQuery;
 import org.apache.solr.common.util.DOMUtil;
-import org.apache.solr.common.util.RegexFileFilter;
 import org.apache.solr.common.util.NamedList;
+import org.apache.solr.common.util.RegexFileFilter;
 import org.apache.solr.handler.PingRequestHandler;
 import org.apache.solr.handler.component.SearchComponent;
+import org.apache.solr.highlight.SolrHighlighter;
 import org.apache.solr.request.LocalSolrQueryRequest;
+import org.apache.solr.request.QueryResponseWriter;
 import org.apache.solr.request.SolrQueryRequest;
 import org.apache.solr.request.SolrRequestHandler;
-import org.apache.solr.request.QueryResponseWriter;
-
 import org.apache.solr.search.CacheConfig;
 import org.apache.solr.search.FastLRUCache;
 import org.apache.solr.search.QParserPlugin;
 import org.apache.solr.search.ValueSourceParser;
+import org.apache.solr.search.fieldcollapse.collector.CollapseCollectorFactory;
+import org.apache.solr.spelling.QueryConverter;
 import org.apache.solr.update.SolrIndexConfig;
 import org.apache.solr.update.processor.UpdateRequestProcessorChain;
-import org.apache.solr.spelling.QueryConverter;
-import org.apache.solr.highlight.SolrHighlighter;
-import org.apache.lucene.search.BooleanQuery;
-import org.apache.lucene.index.IndexDeletionPolicy;
-
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
-
 import org.w3c.dom.Node;
 import org.w3c.dom.NodeList;
 import org.xml.sax.SAXException;
 
 import javax.xml.parsers.ParserConfigurationException;
 import javax.xml.xpath.XPathConstants;
-
-import java.util.*;
-import java.util.regex.Pattern;
-import java.util.regex.Matcher;
 import java.io.FileFilter;
 import java.io.IOException;
 import java.io.InputStream;
+import java.util.*;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
 
 
 /**
@@ -193,6 +190,7 @@
      loadPluginInfo(IndexReaderFactory.class,"indexReaderFactory",false, true);
      loadPluginInfo(UpdateRequestProcessorChain.class,"updateRequestProcessorChain",false, false);
      loadPluginInfo(SolrHighlighter.class,"highlighting",false, false);
+     loadPluginInfo(CollapseCollectorFactory.class, "//fieldCollapsing/collapseCollectorFactory", true, true);
      updateHandlerInfo = loadUpdatehandlerInfo();
 
     Config.log.info("Loaded SolrConfig: " + name);
Index: org/apache/solr/util/DocSetScoreCollector.java
===================================================================
--- org/apache/solr/util/DocSetScoreCollector.java	(revision 0)
+++ org/apache/solr/util/DocSetScoreCollector.java	(revision 0)
@@ -0,0 +1,182 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.solr.util;
+
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.search.Scorer;
+import org.apache.lucene.search.Filter;
+import org.apache.lucene.util.OpenBitSet;
+import org.apache.solr.search.BitDocSet;
+import org.apache.solr.search.DocSet;
+import org.apache.solr.search.DocSetAwareCollector;
+import org.apache.solr.search.DocIterator;
+
+import java.io.IOException;
+
+/**
+ * Collects the documents with the score.
+ */
+public class DocSetScoreCollector extends DocSetAwareCollector {
+  private final float[] scores;
+  private final OpenBitSet bits;
+
+  private Scorer scorer = null;
+  private int docBase = 0;
+
+  /**
+   * Constructs a DocSetHitCollector with the specified parameter.
+   *
+   * @param maxDoc The maximum size of all the documents in the index
+   */
+  public DocSetScoreCollector(int maxDoc) {
+    scores = new float[maxDoc];
+    bits = new OpenBitSet(maxDoc);
+  }
+
+  /**
+   * Collects documents as specified in {@link super#collect(int)}.
+   * Also stores the score associated with this document.
+   *
+   * @param doc The document id to collect
+   * @throws IOException
+   */
+  public void collect(int doc) throws IOException {
+    doc = doc + docBase;
+    bits.fastSet(doc);
+    scores[doc] = scorer.score();
+  }
+
+ /**
+  * {@inheritDoc}
+  */
+  public boolean acceptsDocsOutOfOrder() {
+    return false;
+  }
+
+  // ================================================= Setter/Getter ===================================================
+
+  /**
+   * {@inheritDoc}
+   */
+  public void setNextReader(IndexReader reader, int docBase) throws IOException {
+    this.docBase = docBase;
+  }
+
+  /**
+   * {@inheritDoc}
+   */
+  public void setScorer(Scorer scorer) throws IOException {
+    this.scorer = scorer;
+  }
+
+  /**
+   * Returns a docset of the collected documents.
+   *
+   * @return a docset of the collected documents
+   */
+  public DocSet getDocSet() {
+    return new DelegateDocSet(new BitDocSet(bits), scores);
+  }
+
+  /**
+   * Returns the scores for the collected documents.
+   * The index of the score represents the lucene document identifier.
+   *
+   * @return the scores for the collected documents
+   */
+  public float[] getScores() {
+    return scores;
+  }
+
+
+  // ============================================ Inner Classes ======================================================
+
+  /**
+   * A delegate docset that also has the associated score for each document in the contained docset.
+   */
+  public class DelegateDocSet implements DocSet {
+
+    private final DocSet docSet;
+    private final float[] scores;
+
+    public DelegateDocSet(DocSet docSet, float[] scores) {
+      this.docSet = docSet;
+      this.scores = scores;
+    }
+
+    public void add(int doc) {
+      docSet.add(doc);
+    }
+
+    public void addUnique(int doc) {
+      docSet.addUnique(doc);
+    }
+
+    public int size() {
+      return docSet.size();
+    }
+
+    public boolean exists(int docid) {
+      return docSet.exists(docid);
+    }
+
+    public DocIterator iterator() {
+      return docSet.iterator();
+    }
+
+    public OpenBitSet getBits() {
+      return docSet.getBits();
+    }
+
+    public long memSize() {
+      return docSet.memSize();
+    }
+
+    public DocSet intersection(DocSet other) {
+      return docSet.intersection(other);
+    }
+
+    public int intersectionSize(DocSet other) {
+      return docSet.intersectionSize(other);
+    }
+
+    public DocSet union(DocSet other) {
+      return docSet.union(other);
+    }
+
+    public int unionSize(DocSet other) {
+      return docSet.unionSize(other);
+    }
+
+    public DocSet andNot(DocSet other) {
+      return docSet.andNot(other);
+    }
+
+    public int andNotSize(DocSet other) {
+      return docSet.andNotSize(other);
+    }
+
+    public Filter getTopFilter() {
+      return docSet.getTopFilter();
+    }
+
+    public float[] getScores() {
+      return scores;
+    }
+  }
+
+}
Index: org/apache/solr/handler/component/QueryComponent.java
===================================================================
--- org/apache/solr/handler/component/QueryComponent.java	(revision 885060)
+++ org/apache/solr/handler/component/QueryComponent.java	(working copy)
@@ -19,14 +19,11 @@
 
 import org.apache.lucene.document.Field;
 import org.apache.lucene.index.Term;
-import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.search.*;
-import org.apache.lucene.search.FieldCache.DoubleParser;
-import org.apache.lucene.search.FieldCache.LongParser;
-import org.apache.lucene.search.FieldCache.FloatParser;
-import org.apache.lucene.search.FieldCache.IntParser;
-import org.apache.lucene.search.FieldCache.Parser;
 import org.apache.lucene.queryParser.ParseException;
+import org.apache.lucene.search.FieldComparator;
+import org.apache.lucene.search.Query;
+import org.apache.lucene.search.Sort;
+import org.apache.lucene.search.SortField;
 import org.apache.solr.common.SolrDocument;
 import org.apache.solr.common.SolrDocumentList;
 import org.apache.solr.common.SolrException;
@@ -38,15 +35,14 @@
 import org.apache.solr.common.util.StrUtils;
 import org.apache.solr.request.SolrQueryRequest;
 import org.apache.solr.request.SolrQueryResponse;
+import org.apache.solr.schema.FieldType;
 import org.apache.solr.schema.SchemaField;
-import org.apache.solr.schema.FieldType;
 import org.apache.solr.search.*;
 import org.apache.solr.util.SolrPluginUtils;
 
 import java.io.IOException;
 import java.net.URL;
 import java.util.*;
-import java.text.Collator;
 
 /**
  * TODO!
@@ -185,7 +181,15 @@
     rsp.add("response",rb.getResults().docList);
     rsp.getToLog().add("hits", rb.getResults().docList.matches());
 
+    doFSV(rb, searcher);
+    doPrefetch(rb);
+  }
 
+  protected void doFSV(ResponseBuilder rb, SolrIndexSearcher searcher) throws IOException
+  {
+    SolrQueryRequest req = rb.req;
+    SolrQueryResponse rsp = rb.rsp;
+
     // The query cache doesn't currently store sort field values, and SolrIndexSearcher doesn't
     // currently have an option to return sort field values.  Because of this, we
     // take the documents given and re-derive the sort values.
@@ -262,7 +266,12 @@
 
       rsp.add("sort_values", sortVals);
     }
+  }
 
+  protected void doPrefetch(ResponseBuilder rb) throws IOException
+  {
+    SolrQueryRequest req = rb.req;
+    SolrQueryResponse rsp = rb.rsp;
     //pre-fetch returned documents
     if (!req.getParams().getBool(ShardParams.IS_SHARD,false) && rb.getResults().docList != null && rb.getResults().docList.size()<=50) {
       // TODO: this may depend on the highlighter component (or other components?)
@@ -513,6 +522,9 @@
       // we already have the field sort values
       sreq.params.remove(ResponseBuilder.FIELD_SORT_VALUES);
 
+			// disable collapser
+			sreq.params.remove("collapse.field");			
+
       // make sure that the id is returned for correlation
       String fl = sreq.params.get(CommonParams.FL);
       if (fl != null) {
@@ -550,10 +562,12 @@
       for (SolrDocument doc : docs) {
         Object id = doc.getFieldValue(keyFieldName);
         ShardDoc sdoc = rb.resultIds.get(id.toString());
-        if (returnScores && sdoc.score != null) {
-          doc.setField("score", sdoc.score);
-        }
-        rb._responseDocs.set(sdoc.positionInResponse, doc);
+				if (sdoc != null) {
+					if (returnScores && sdoc.score != null) {
+						doc.setField("score", sdoc.score);
+					}
+					rb._responseDocs.set(sdoc.positionInResponse, doc);
+				}
       }      
     }
   }
Index: org/apache/solr/handler/component/CollapseComponent.java
===================================================================
--- org/apache/solr/handler/component/CollapseComponent.java	(revision 0)
+++ org/apache/solr/handler/component/CollapseComponent.java	(revision 0)
@@ -0,0 +1,296 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.solr.handler.component;
+
+import org.apache.solr.common.SolrException;
+import org.apache.solr.common.params.CollapseParams;
+import org.apache.solr.common.params.SolrParams;
+import org.apache.solr.common.util.NamedList;
+import org.apache.solr.core.SolrCore;
+import org.apache.solr.request.SolrQueryRequest;
+import org.apache.solr.request.SolrQueryResponse;
+import org.apache.solr.search.DocListAndSet;
+import org.apache.solr.search.SolrIndexSearcher;
+import org.apache.solr.search.fieldcollapse.AdjacentDocumentCollapser;
+import org.apache.solr.search.fieldcollapse.DocumentCollapseResult;
+import org.apache.solr.search.fieldcollapse.DocumentCollapser;
+import org.apache.solr.search.fieldcollapse.NonAdjacentDocumentCollapser;
+import org.apache.solr.search.fieldcollapse.collector.*;
+import org.apache.solr.util.plugin.SolrCoreAware;
+
+import java.io.IOException;
+import java.net.URL;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+/**
+ * Collapse component is responsible for do field collapsing with an implementation of {@link org.apache.solr.search.fieldcollapse.DocumentCollapser},
+ * that does the most of the work. Collapsing is activated by specifying <code>collapse.field</code> in the request
+ * as parameter.
+ * If this parameter is not specified it falls back to the {@link QueryComponent#process(ResponseBuilder)} method.
+ * <br/><br/>
+ * If the parameter <code>collapse.facet</code> with value <code>after</code> is specified,
+ * it replaces the collapsed docSet from <code>DocListAndSet</code> with the uncollapsed docset, so that facetation
+ * counts are based on the uncollapsed search result (which is usually desired behaviour)
+ *
+ * @version $Id: CollapseComponent.java 602341 2007-12-08 07:27:49Z ryan $
+ * @since solr 1.3
+ */
+public class CollapseComponent extends QueryComponent implements SolrCoreAware {
+
+  private List<CollapseCollectorFactory> collapseCollectorFactories = new ArrayList<CollapseCollectorFactory>();
+  private List<String> collapseCollectorFactoryNames;
+
+  /**
+   * {@inheritDoc}
+   */
+  @Override
+  @SuppressWarnings("unchecked")
+  public void init(NamedList args) {
+    super.init(args);
+    collapseCollectorFactoryNames = (List<String>) args.get("collapseCollectorFactories");
+  }
+
+  /**
+   * {@inheritDoc}
+   */
+  public void inform(SolrCore core) {
+    if (collapseCollectorFactoryNames == null) {
+      collapseCollectorFactories.add(new DocumentGroupCountCollapseCollectorFactory());
+      collapseCollectorFactories.add(new FieldValueCountCollapseCollectorFactory());
+      collapseCollectorFactories.add(new DocumentFieldsCollapseCollectorFactory());
+      // ok is not have its done normally, but works for now... need something like loadSearchComponents() and addIfNotPresent()
+      // but requires more changes outside field collapse code. 
+      AggregateCollapseCollectorFactory aggregateCollapseCollectorFactory = new AggregateCollapseCollectorFactory();
+      aggregateCollapseCollectorFactory.init(new NamedList());
+      collapseCollectorFactories.add(aggregateCollapseCollectorFactory);
+      return;
+    }
+
+    Map<String, CollapseCollectorFactory> registry = new HashMap<String, CollapseCollectorFactory>();
+    core.initPlugins(registry, CollapseCollectorFactory.class);
+    for (String name : collapseCollectorFactoryNames) {
+      CollapseCollectorFactory factory = registry.get(name);
+      if (factory == null) {
+        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, "Unknown collapse collector factory: " + name);
+      }
+
+      collapseCollectorFactories.add(factory);
+    }
+  }
+
+  /**
+   * Parses some parameters from the request in preparation for the collapsing when collapsing is enabled otherwise
+   * behaves like {@link super#prepare(ResponseBuilder)}.
+   *
+   * @param rb The response builder of the current search request
+   * @throws IOException When index search problems occur
+   */
+  @Override
+  public void prepare(ResponseBuilder rb) throws IOException {
+    super.prepare(rb);
+    rb.req.getContext().put("collapseRequest", resolveCollapseRequest(rb));
+  }
+
+  /**
+   * Actually run the query
+   */
+  @Override
+  public void process(ResponseBuilder rb) throws IOException {
+    CollapseRequest collapseRequest = (CollapseRequest) rb.req.getContext().remove("collapseRequest");
+    if (collapseRequest == null) {
+      super.process(rb);
+      return;
+    }
+    doProcess(rb, collapseRequest);
+  }
+
+  @Override
+  public void handleResponses(ResponseBuilder rb, ShardRequest sreq) {
+    super.handleResponses(rb, sreq);
+    if ((sreq.purpose & ShardRequest.PURPOSE_GET_TOP_IDS) != 0) {
+      mergeCollapseCounts(rb, sreq);
+    }
+  }
+
+  // ================================================= Helpers =========================================================
+
+  /**
+   * Resolves the field collapse parameters from the request and constructs a <code>CollapseRequest</code> from it.
+   *
+   * @param rb The response builder that contains the request
+   * @return a <code>CollapseRequest</code> based on the parameters in the request
+   * @throws IOException When IO related problems occur
+   */
+  protected CollapseRequest resolveCollapseRequest(ResponseBuilder rb) throws IOException {
+    SolrParams params = rb.req.getParams();
+    if (params.get(CollapseParams.COLLAPSE_FIELD) == null) {
+      return null;
+    }
+
+    String facet = params.get(CollapseParams.COLLAPSE_FACET);
+    CollapseParams.CollapseFacet collapseFacet = (facet != null) ? CollapseParams.CollapseFacet.get(facet) : CollapseParams.CollapseFacet.AFTER;
+
+    String type = params.get(CollapseParams.COLLAPSE_TYPE);
+    CollapseParams.CollapseType collapseType = (type != null) ? CollapseParams.CollapseType.get(type) : CollapseParams.CollapseType.NORMAL;
+    DocumentCollapser documentCollapser = constructCollapser(rb, collapseType);
+    return new CollapseRequest(documentCollapser, collapseFacet);
+  }
+
+  /**
+   * Executes a search and collapses the search results.
+   *
+   * @param rb The response builder of the current search request
+   * @param collapseRequest The current collapse request
+   * @throws IOException When index search problems occur
+   */
+  protected void doProcess(ResponseBuilder rb, CollapseComponent.CollapseRequest collapseRequest) throws IOException {
+    SolrQueryResponse rsp = rb.rsp;
+    SolrQueryRequest req = rb.req;
+    SolrIndexSearcher searcher = req.getSearcher();
+    DocumentCollapseResult collapseResult =
+            collapseRequest.getCollapser().collapse(rb.getQuery(), rb.getFilters(), rb.getSortSpec().getSort());
+
+    DocListAndSet results = searcher.getDocListAndSet(rb.getQuery(),
+      collapseResult == null ? rb.getFilters() : null,
+      collapseResult.getCollapsedDocset(),
+      rb.getSortSpec().getSort(),
+      rb.getSortSpec().getOffset(),
+      rb.getSortSpec().getCount(),
+      rb.getFieldFlags());
+
+    //for getting the facet count BEFORE the collapsing, we must
+    //get the doc. collection without filtering by the collapseResult.
+    boolean facetAfterCollapse = (collapseRequest.getCollapseFacet() == CollapseParams.CollapseFacet.AFTER);
+    if (!facetAfterCollapse) {
+      results.docSet = collapseResult.getUnCollapsedDocset();
+    }
+
+    rb.setResults(results);
+    rsp.add("collapse_counts", collapseRequest.getCollapser().getCollapseInfo(searcher, results.docList));
+    rsp.add("response", results.docList);
+
+    doFSV(rb, searcher);
+    doPrefetch(rb);
+  }
+
+  /**
+   * Returns the field collapser implementation based on the specified collapseType
+   *
+   * @param rb           The response builder of the current search request
+   * @param collapseType The type of collapsing for the current search
+   * @return collapser implementation
+   * @throws IOException When index search problems occur
+   */
+  protected DocumentCollapser constructCollapser(ResponseBuilder rb, CollapseParams.CollapseType collapseType) throws IOException {
+    switch (collapseType) {
+      case ADJACENT:
+        return new AdjacentDocumentCollapser(rb, collapseCollectorFactories);
+      case NORMAL:
+        return new NonAdjacentDocumentCollapser(rb, collapseCollectorFactories);
+      default:
+        throw new UnsupportedOperationException("Method not implemented");
+    }
+  }
+
+  /**
+   * Merges the collapse responses from the shards into one distributed collapse response.
+   *
+   * @param rb The response builder
+   * @param sreq The shard request
+   */
+  protected void mergeCollapseCounts(ResponseBuilder rb, ShardRequest sreq) {
+    String collapseField = "";
+		NamedList collapseResults = new NamedList<Object>();
+
+		for (ShardResponse srsp : sreq.responses) {
+			NamedList collapseInfo = (NamedList<Object>) srsp.getSolrResponse().getResponse().get("collapse_counts");
+			if (collapseInfo != null) {
+				collapseField = (String) collapseInfo.get("field");
+				NamedList collapseResult = (NamedList) collapseInfo.get("results");
+        for (int i = 0; i < collapseResult.size(); i++) {
+          String collapseGroupId = collapseResult.getName(i);
+          ShardDoc sdoc = rb.resultIds.get(collapseGroupId);
+				  if (sdoc != null) {
+            collapseResults.add(collapseGroupId, collapseResult.getVal(i));
+          }
+        }
+			}
+		}
+
+		if (collapseResults.size() > 0) {
+			NamedList<Object> result = new NamedList<Object>();
+			result.add("field", collapseField);
+			result.add("results", collapseResults);
+			rb.rsp.add("collapse_counts", result);
+		}
+  }
+
+  /////////////////////////////////////////////
+  ///  SolrInfoMBean
+  ////////////////////////////////////////////
+
+  @Override
+  public String getDescription() {
+    return "Field Collapsing";
+  }
+
+  @Override
+  public String getVersion() {
+    return "";
+  }
+
+  @Override
+  public String getSourceId() {
+    return "";
+  }
+
+  @Override
+  public String getSource() {
+    return "";
+  }
+
+  @Override
+  public URL[] getDocs() {
+    return null;
+  }
+
+
+  // ============================================ Inner Classes ========================================================
+
+  static class CollapseRequest {
+
+    private final DocumentCollapser collapser;
+    private final CollapseParams.CollapseFacet collapseFacet;
+
+    private CollapseRequest(DocumentCollapser collapser, CollapseParams.CollapseFacet collapseFacet) {
+      this.collapser = collapser;
+      this.collapseFacet = collapseFacet;
+    }
+
+    public DocumentCollapser getCollapser() {
+      return collapser;
+    }
+
+    public CollapseParams.CollapseFacet getCollapseFacet() {
+      return collapseFacet;
+    }
+
+  }
+}
